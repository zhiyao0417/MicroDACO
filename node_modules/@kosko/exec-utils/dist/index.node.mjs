import crossSpawn from 'cross-spawn';
import assert from 'node:assert';

function booleanArg(name, value) {
    return value ? [
        `--${name}`
    ] : [];
}
function stringArg(name, value) {
    return value ? [
        `--${name}`,
        value
    ] : [];
}
function stringArrayArg(name, values = []) {
    return values.reduce((acc, value)=>[
            ...acc,
            `--${name}`,
            value
        ], []);
}

class SpawnError extends Error {
    constructor(options){
        super([
            `Command failed with exit code ${options.exitCode}: ${options.command} ${options.args.join(" ")}`,
            options.stderr.trim(),
            options.stdout.trim()
        ].filter(Boolean).join("\n")), this.exitCode = options.exitCode, this.command = options.command, this.args = options.args, this.stdout = options.stdout, this.stderr = options.stderr;
    }
}
SpawnError.prototype.name = "SpawnError";

function spawn(command, args = [], options = {}) {
    let proc = crossSpawn(command, args, options), stdoutChunks = [], stderrChunks = [];
    return options.input && (assert(proc.stdin), proc.stdin.end(options.input)), proc.stdout?.on("data", (chunk)=>{
        stdoutChunks.push(chunk);
    }), proc.stderr?.on("data", (chunk)=>{
        stderrChunks.push(chunk);
    }), new Promise((resolve, reject)=>{
        proc.on("error", (err)=>reject(err)), proc.on("close", (code)=>{
            let stdout = stdoutChunks.join(""), stderr = stderrChunks.join("");
            code ? reject(new SpawnError({
                exitCode: code,
                command,
                args,
                stdout,
                stderr
            })) : resolve({
                stdout,
                stderr
            });
        });
    });
}

export { SpawnError, booleanArg, spawn, stringArg, stringArrayArg };
//# sourceMappingURL=index.node.mjs.map
