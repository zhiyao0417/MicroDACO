import pc from 'picocolors';
import cleanStack from 'clean-stack';
import stringify from 'fast-safe-stringify';
import { isRecord } from '@kosko/common-utils';
import { stderr } from 'node:process';

var LogLevel;
!function(LogLevel) {
    LogLevel[LogLevel.Trace = 1] = "Trace", LogLevel[LogLevel.Debug = 2] = "Debug", LogLevel[LogLevel.Info = 3] = "Info", LogLevel[LogLevel.Warn = 4] = "Warn", LogLevel[LogLevel.Error = 5] = "Error", LogLevel[LogLevel.Fatal = 6] = "Fatal";
}(LogLevel || (LogLevel = {}));
let LOG_LEVEL_MAP = {
    trace: LogLevel.Trace,
    debug: LogLevel.Debug,
    info: LogLevel.Info,
    warn: LogLevel.Warn,
    error: LogLevel.Error,
    fatal: LogLevel.Fatal
};
function logLevelFromString(level) {
    return LOG_LEVEL_MAP[level];
}

class Logger {
    log(level, message, options = {}) {
        if (this.enabled(level)) {
            let { time =new Date() , ...rest } = options;
            this.writer.write({
                loggerLevel: this.level,
                level,
                message,
                time,
                ...rest
            });
        }
    }
    getLevel() {
        return this.level;
    }
    setLevel(level) {
        this.level = level;
    }
    enabled(level) {
        return this.level <= level;
    }
    getWriter() {
        return this.writer;
    }
    setWriter(writer) {
        this.writer = writer;
    }
    constructor(options){
        this.level = options.level, this.writer = options.writer;
    }
}
function createLoggerFactory(createWriter) {
    return (options = {})=>{
        let { level =LogLevel.Info , writer =createWriter()  } = options;
        return new Logger({
            level,
            writer
        });
    };
}

let COLOR_MAP = {
    [LogLevel.Trace]: pc.gray,
    [LogLevel.Debug]: pc.cyan,
    [LogLevel.Info]: pc.green,
    [LogLevel.Warn]: pc.yellow,
    [LogLevel.Error]: pc.red,
    [LogLevel.Fatal]: pc.bgRed
}, LEVEL_MAX_LENGTH = Math.max(...Object.keys(LogLevel).map((x)=>x.length));
function formatData(data) {
    return stringify(data, void 0, "  ");
}
class NodeLogWriter {
    write(log) {
        let { level , time , message , error , data  } = log, content = `${function(level) {
            let label = LogLevel[level].toLowerCase().padEnd(LEVEL_MAX_LENGTH, " ");
            return COLOR_MAP[level](label);
        }(level)} -`;
        log.loggerLevel <= LogLevel.Debug && (content = `${pc.gray(`[${function(time) {
            let h = time.getHours().toString().padStart(2, "0"), m = time.getMinutes().toString().padStart(2, "0"), s = time.getSeconds().toString().padStart(2, "0"), ms = time.getMilliseconds().toString().padStart(3, "0");
            return `${h}:${m}:${s}.${ms}`;
        }(time)}]`)} ${content}`), message ? content += ` ${message}` : isRecord(error) && "string" == typeof error.message && (content += ` ${error.message}`), null != data && (content += ` ${formatData(data)}`), error && (content += `\n${pc.gray(function(err) {
            if ("string" == typeof err) return err;
            if (isRecord(err)) {
                if ("string" == typeof err.stack) return cleanStack(err.stack, {
                    pretty: !0
                });
                if ("string" == typeof err.message) return err.message;
            }
            return formatData(err);
        }(error))}`), stderr.write(content + "\n");
    }
}

const createLogger = createLoggerFactory(()=>new NodeLogWriter());

class ConsoleLogWriter {
    write(log) {
        let args = [
            log.message,
            log.data,
            log.error
        ].filter(Boolean);
        switch(log.level){
            case LogLevel.Trace:
                console.trace(...args);
                break;
            case LogLevel.Debug:
                console.debug(...args);
                break;
            case LogLevel.Info:
                console.info(...args);
                break;
            case LogLevel.Warn:
                console.warn(...args);
                break;
            case LogLevel.Error:
            case LogLevel.Fatal:
                console.error(...args);
        }
    }
}

class SilentLogWriter {
    write() {}
}

var index = createLogger();

export { ConsoleLogWriter, LogLevel, Logger, SilentLogWriter, createLogger, index as default, logLevelFromString };
//# sourceMappingURL=index.node.mjs.map
