'use strict';

var toml = require('@iarna/toml');
var promises = require('node:fs/promises');
var node_path = require('node:path');
var superstruct = require('superstruct');
var logger = require('@kosko/log');
var commonUtils = require('@kosko/common-utils');
var node_process = require('node:process');

function _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }

var toml__default = /*#__PURE__*/_interopDefault(toml);
var logger__default = /*#__PURE__*/_interopDefault(logger);

const environmentConfigSchema = superstruct.object({
    require: superstruct.optional(superstruct.array(superstruct.string())),
    components: superstruct.optional(superstruct.array(superstruct.string())),
    loaders: superstruct.optional(superstruct.array(superstruct.string()))
});
const configSchema = superstruct.assign(environmentConfigSchema, superstruct.object({
    environments: superstruct.optional(superstruct.record(superstruct.string(), environmentConfigSchema)),
    paths: superstruct.optional(superstruct.object({
        environment: superstruct.optional(superstruct.object({
            global: superstruct.optional(superstruct.string()),
            component: superstruct.optional(superstruct.string())
        }))
    })),
    extensions: superstruct.optional(superstruct.array(superstruct.string())),
    baseEnvironment: superstruct.optional(superstruct.string()),
    bail: superstruct.optional(superstruct.boolean()),
    concurrency: superstruct.optional(superstruct.min(superstruct.integer(), 1))
}));

class ValidationError extends Error {
    constructor(errors){
        super([
            'Config file "kosko.toml" is invalid.',
            ...errors.map((f)=>`- "${f.path.join(".")}": ${f.message}`)
        ].join("\n")), this.errors = errors;
    }
}
ValidationError.prototype.name = "ValidationError";
function validate(data) {
    let result = superstruct.validate(data, configSchema);
    if (result[0]) throw new ValidationError(result[0].failures());
    return result[1];
}

async function loadConfig(path) {
    let content = await promises.readFile(path, "utf8"), data = await toml__default.default.parse.async(content);
    return logger__default.default.log(logger.LogLevel.Debug, `Found config at "${path}"`), validate(data);
}
async function searchConfig(path = node_process.cwd()) {
    let configPath = node_path.join(path, "kosko.toml");
    try {
        return await loadConfig(configPath);
    } catch (err) {
        if ("ENOENT" === commonUtils.getErrorCode(err)) return {};
        throw logger__default.default.log(logger.LogLevel.Debug, "Config load failed", {
            error: err
        }), err;
    }
}
function flatten(...arrays) {
    return arrays.flatMap((x)=>x ?? []);
}
function getConfig(config, envs) {
    let { environments ={}  } = config, envConfigs = commonUtils.toArray(envs).map((env)=>environments[env]).filter(Boolean);
    return envConfigs.length ? {
        require: flatten(config.require, ...envConfigs.map((e)=>e.require)),
        components: flatten(config.components, ...envConfigs.map((e)=>e.components)),
        loaders: flatten(config.loaders, ...envConfigs.map((e)=>e.loaders))
    } : {
        require: config.require ?? [],
        components: config.components ?? [],
        loaders: config.loaders ?? []
    };
}

exports.ValidationError = ValidationError;
exports.getConfig = getConfig;
exports.loadConfig = loadConfig;
exports.searchConfig = searchConfig;
exports.validate = validate;
//# sourceMappingURL=index.node.cjs.map
