import toml from '@iarna/toml';
import { readFile } from 'node:fs/promises';
import { join } from 'node:path';
import { object, optional, array, string, assign, record, boolean, min, integer, validate as validate$1 } from 'superstruct';
import logger, { LogLevel } from '@kosko/log';
import { getErrorCode, toArray } from '@kosko/common-utils';
import { cwd } from 'node:process';

const environmentConfigSchema = object({
    require: optional(array(string())),
    components: optional(array(string())),
    loaders: optional(array(string()))
});
const configSchema = assign(environmentConfigSchema, object({
    environments: optional(record(string(), environmentConfigSchema)),
    paths: optional(object({
        environment: optional(object({
            global: optional(string()),
            component: optional(string())
        }))
    })),
    extensions: optional(array(string())),
    baseEnvironment: optional(string()),
    bail: optional(boolean()),
    concurrency: optional(min(integer(), 1))
}));

class ValidationError extends Error {
    constructor(errors){
        super([
            'Config file "kosko.toml" is invalid.',
            ...errors.map((f)=>`- "${f.path.join(".")}": ${f.message}`)
        ].join("\n")), this.errors = errors;
    }
}
ValidationError.prototype.name = "ValidationError";
function validate(data) {
    let result = validate$1(data, configSchema);
    if (result[0]) throw new ValidationError(result[0].failures());
    return result[1];
}

async function loadConfig(path) {
    let content = await readFile(path, "utf8"), data = await toml.parse.async(content);
    return logger.log(LogLevel.Debug, `Found config at "${path}"`), validate(data);
}
async function searchConfig(path = cwd()) {
    let configPath = join(path, "kosko.toml");
    try {
        return await loadConfig(configPath);
    } catch (err) {
        if ("ENOENT" === getErrorCode(err)) return {};
        throw logger.log(LogLevel.Debug, "Config load failed", {
            error: err
        }), err;
    }
}
function flatten(...arrays) {
    return arrays.flatMap((x)=>x ?? []);
}
function getConfig(config, envs) {
    let { environments ={}  } = config, envConfigs = toArray(envs).map((env)=>environments[env]).filter(Boolean);
    return envConfigs.length ? {
        require: flatten(config.require, ...envConfigs.map((e)=>e.require)),
        components: flatten(config.components, ...envConfigs.map((e)=>e.components)),
        loaders: flatten(config.loaders, ...envConfigs.map((e)=>e.loaders))
    } : {
        require: config.require ?? [],
        components: config.components ?? [],
        loaders: config.loaders ?? []
    };
}

export { ValidationError, getConfig, loadConfig, searchConfig, validate };
//# sourceMappingURL=index.node.mjs.map
