import deepMerge from 'deepmerge';
import { isPlainObject } from 'is-plain-object';
import { toArray, getErrorCode } from '@kosko/common-utils';
import { getRequireExtensions, resolve, importPath } from '@kosko/require';
import { join } from 'node:path';
import { cwd } from 'node:process';
import logger, { LogLevel } from '@kosko/log';

function reduce(reducers, componentName) {
    return reducers.reduce((target, reducer)=>reducer.reduce(target, componentName), {});
}
async function reduceAsync(reducers, componentName) {
    let target = {};
    for (let reducer of reducers)target = await reducer.reduce(target, componentName);
    return target;
}

function merge(data) {
    return deepMerge.all(data, {
        isMergeableObject: isPlainObject
    });
}
async function mergeAsync(data) {
    let values = await Promise.all(data);
    return merge(values);
}

function createEnvironment({ cwd ="/" , extensions =[] , setReducers , resetReducers , reduce  }) {
    return {
        cwd,
        paths: {
            global: "environments/#{environment}",
            component: "environments/#{environment}/#{component}"
        },
        extensions,
        setReducers,
        resetReducers,
        global: ()=>reduce(),
        component: (name)=>reduce(name)
    };
}
function createLoaderReducers(loader, mergeValues) {
    return [
        {
            name: "global",
            reduce: (values)=>mergeValues([
                    values,
                    ...toArray(loader.global())
                ])
        },
        {
            name: "component",
            reduce: (values, componentName)=>componentName ? mergeValues([
                    values,
                    ...toArray(loader.component(componentName))
                ]) : values
        }
    ];
}
function createSyncLoaderReducers(loader) {
    return createLoaderReducers(loader, merge);
}
function createAsyncLoaderReducers(loader) {
    return createLoaderReducers(loader, mergeAsync);
}
function createReducerList(initialReducers = []) {
    let reducers = [];
    function resetReducers() {
        reducers = [
            ...initialReducers
        ];
    }
    return resetReducers(), {
        getReducers: ()=>reducers,
        setReducers (callback) {
            reducers = callback([
                ...reducers
            ]);
        },
        resetReducers
    };
}
function createSyncReducerExecutor({ getReducers  }) {
    return {
        reduce: (componentName)=>reduce(getReducers(), componentName)
    };
}
function createAsyncReducerExecutor({ getReducers  }) {
    return {
        reduce: (componentName)=>reduceAsync(getReducers(), componentName)
    };
}

function createAsyncEnvironment() {
    let reducers = createReducerList(), { reduce  } = createAsyncReducerExecutor(reducers);
    return createEnvironment({
        ...reducers,
        reduce
    });
}

function createSyncEnvironment() {
    let reducers = createReducerList(), { reduce  } = createSyncReducerExecutor(reducers);
    return createEnvironment({
        ...reducers,
        reduce
    });
}

let rTemplate = /#\{(\w+)\}/g;
function formatPath(path, data) {
    return path.replace(rTemplate, (s, key)=>data[key] || s);
}

function getNodeExtensions() {
    return getRequireExtensions().map((ext)=>ext.substring(1));
}
function createNodeEnvironment({ cwd: cwd$1 =cwd() , createReducerExecutor , requireModule , mergeValues  }) {
    function requireAllEnvs(template, component) {
        if (!environment.env) return [];
        let envs = toArray(environment.env);
        return envs.map((env)=>{
            let path = formatPath(template, {
                environment: env,
                ...component && {
                    component
                }
            });
            return requireModule(environment, join(environment.cwd, path));
        });
    }
    let reducers = createReducerList(createLoaderReducers({
        global: ()=>requireAllEnvs(environment.paths.global),
        component: (name)=>requireAllEnvs(environment.paths.component, name)
    }, mergeValues)), { reduce  } = createReducerExecutor(reducers), environment = createEnvironment({
        cwd: cwd$1,
        extensions: getNodeExtensions(),
        setReducers: reducers.setReducers,
        resetReducers: reducers.resetReducers,
        reduce
    });
    return environment;
}

function createNodeCJSEnvironment(options = {}) {
    return createNodeEnvironment({
        ...options,
        createReducerExecutor: createSyncReducerExecutor,
        mergeValues: merge,
        requireModule (env, id) {
            try {
                let mod = require(id);
                return mod && mod.__esModule ? mod.default : mod;
            } catch (err) {
                if ("MODULE_NOT_FOUND" === getErrorCode(err)) return logger.log(LogLevel.Debug, `Cannot find module: ${id}`, {
                    error: err
                }), {};
                throw err;
            }
        }
    });
}

function createNodeESMEnvironment(options = {}) {
    return createNodeEnvironment({
        ...options,
        createReducerExecutor: createAsyncReducerExecutor,
        mergeValues: mergeAsync,
        async requireModule (env, id) {
            let path = await resolve(id, {
                extensions: env.extensions.map((ext)=>`.${ext}`)
            });
            if (!path) return logger.log(LogLevel.Debug, "Module not found", {
                data: {
                    path: id,
                    extensions: env.extensions
                }
            }), {};
            logger.log(LogLevel.Debug, `Importing ${path}`);
            let mod = await importPath(path);
            return mod.default;
        }
    });
}

const env = createNodeESMEnvironment();

export { createAsyncEnvironment, createAsyncLoaderReducers, createNodeCJSEnvironment, createNodeESMEnvironment, createSyncEnvironment, createSyncLoaderReducers, env as default };
//# sourceMappingURL=index.node.mjs.map
