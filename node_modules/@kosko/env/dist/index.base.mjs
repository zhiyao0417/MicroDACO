import deepMerge from 'deepmerge';
import { isPlainObject } from 'is-plain-object';
import { toArray } from '@kosko/common-utils';

function reduce(reducers, componentName) {
    return reducers.reduce((target, reducer)=>reducer.reduce(target, componentName), {});
}
async function reduceAsync(reducers, componentName) {
    let target = {};
    for (let reducer of reducers)target = await reducer.reduce(target, componentName);
    return target;
}

function merge(data) {
    return deepMerge.all(data, {
        isMergeableObject: isPlainObject
    });
}
async function mergeAsync(data) {
    let values = await Promise.all(data);
    return merge(values);
}

function createEnvironment({ cwd ="/" , extensions =[] , setReducers , resetReducers , reduce  }) {
    return {
        cwd,
        paths: {
            global: "environments/#{environment}",
            component: "environments/#{environment}/#{component}"
        },
        extensions,
        setReducers,
        resetReducers,
        global: ()=>reduce(),
        component: (name)=>reduce(name)
    };
}
function createLoaderReducers(loader, mergeValues) {
    return [
        {
            name: "global",
            reduce: (values)=>mergeValues([
                    values,
                    ...toArray(loader.global())
                ])
        },
        {
            name: "component",
            reduce: (values, componentName)=>componentName ? mergeValues([
                    values,
                    ...toArray(loader.component(componentName))
                ]) : values
        }
    ];
}
function createSyncLoaderReducers(loader) {
    return createLoaderReducers(loader, merge);
}
function createAsyncLoaderReducers(loader) {
    return createLoaderReducers(loader, mergeAsync);
}
function createReducerList(initialReducers = []) {
    let reducers = [];
    function resetReducers() {
        reducers = [
            ...initialReducers
        ];
    }
    return resetReducers(), {
        getReducers: ()=>reducers,
        setReducers (callback) {
            reducers = callback([
                ...reducers
            ]);
        },
        resetReducers
    };
}
function createSyncReducerExecutor({ getReducers  }) {
    return {
        reduce: (componentName)=>reduce(getReducers(), componentName)
    };
}
function createAsyncReducerExecutor({ getReducers  }) {
    return {
        reduce: (componentName)=>reduceAsync(getReducers(), componentName)
    };
}

function createAsyncEnvironment() {
    let reducers = createReducerList(), { reduce  } = createAsyncReducerExecutor(reducers);
    return createEnvironment({
        ...reducers,
        reduce
    });
}

function createSyncEnvironment() {
    let reducers = createReducerList(), { reduce  } = createSyncReducerExecutor(reducers);
    return createEnvironment({
        ...reducers,
        reduce
    });
}

function createNodeCJSEnvironment(options = {}) {
    throw Error("createNodeCJSEnvironment is only supported on Node.js");
}

function createNodeESMEnvironment(options = {}) {
    throw Error("createNodeESMEnvironment is only supported on Node.js and Deno");
}

const env = createAsyncEnvironment();

export { createAsyncEnvironment, createAsyncLoaderReducers, createNodeCJSEnvironment, createNodeESMEnvironment, createSyncEnvironment, createSyncLoaderReducers, env as default };
//# sourceMappingURL=index.base.mjs.map
