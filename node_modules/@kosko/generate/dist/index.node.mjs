import AggregateError from '@kosko/aggregate-error';
import { isRecord } from '@kosko/common-utils';
import extractStack from 'extract-stack';
import yaml from 'js-yaml';
import stringify from 'fast-safe-stringify';
import logger, { LogLevel } from '@kosko/log';
import pLimit from 'p-limit';
import { getRequireExtensions, resolve as resolve$1, importPath } from '@kosko/require';
import { readdir } from 'node:fs/promises';
import { posix, join } from 'node:path';
import mm from 'micromatch';

let STACK_INDENT = "    ";
function aggregateErrors(errors) {
    return 1 === errors.length ? errors[0] : new AggregateError(errors);
}
function decorateErrorStack(err, values) {
    let origStack = extractStack(err.stack);
    for (let [key, value] of (err.stack = `${err.name}: ${err.message}`, Object.entries(values)))err.stack += `\n${STACK_INDENT}${key}: ${value}`;
    origStack && (err.stack += "\n" + origStack);
}
function generateCauseMessage(cause) {
    if ("string" == typeof cause) return cause;
    if (isRecord(cause)) {
        let { name , message , stack  } = cause;
        if ("string" != typeof message) return;
        let result = `${"string" == typeof name && name || "Error"}: ${message}`;
        if ("string" == typeof stack) {
            let extracted = extractStack(stack);
            extracted && (result += "\n" + extracted.split("\n").map((line)=>STACK_INDENT + line).join("\n"));
        }
        return result;
    }
}
class ResolveError extends Error {
    constructor(message, options = {}){
        super(message), this.path = options.path, this.index = options.index, this.cause = options.cause, this.value = options.value, function(value) {
            if (!isRecord(value)) return !1;
            let { apiVersion , kind , metadata  } = value;
            return "string" == typeof apiVersion && "string" == typeof kind && isRecord(metadata) && "string" == typeof metadata.name;
        }(this.value) && (this.component = {
            apiVersion: this.value.apiVersion,
            kind: this.value.kind,
            name: this.value.metadata.name,
            namespace: this.value.metadata.namespace
        });
        let cause = generateCauseMessage(this.cause);
        decorateErrorStack(this, {
            ...this.path && {
                Path: this.path
            },
            ...this.index?.length && {
                Index: `[${this.index.join(", ")}]`
            },
            ...this.component && {
                Kind: `${this.component.apiVersion}/${this.component.kind}`,
                ...this.component.namespace && {
                    Namespace: this.component.namespace
                },
                Name: this.component.name
            },
            ...cause && {
                Cause: cause
            }
        });
    }
}
ResolveError.prototype.name = "ResolveError";
class GenerateError extends Error {
    constructor(message, options = {}){
        super(message), this.path = options.path, this.cause = options.cause;
        let cause = generateCauseMessage(this.cause);
        decorateErrorStack(this, {
            ...this.path && {
                Path: this.path
            },
            ...cause && {
                Cause: cause
            }
        });
    }
}
GenerateError.prototype.name = "GenerateError";

var PrintFormat;
function stringifyYAML(data) {
    return yaml.dump(data, {
        noRefs: !0
    });
}
function stringifyJSON(data) {
    return stringify(data, void 0, "  ");
}
!function(PrintFormat) {
    PrintFormat.YAML = "yaml", PrintFormat.JSON = "json";
}(PrintFormat || (PrintFormat = {}));
let printers = {
    [PrintFormat.YAML] (writer, data) {
        writer.write(stringifyYAML(data));
    },
    [PrintFormat.JSON] (writer, data) {
        writer.write(stringifyJSON(data));
    }
}, arrPrinters = {
    [PrintFormat.YAML] (writer, data) {
        for (let item of data)writer.write("---\n" + stringifyYAML(item));
    },
    [PrintFormat.JSON] (writer, data) {
        writer.write(stringifyJSON({
            apiVersion: "v1",
            kind: "List",
            items: data
        }));
    }
};
function print(result, { format , writer  }) {
    let data = result.manifests.map((manifest)=>manifest.data);
    data.length && (data.length > 1 ? arrPrinters[format](writer, data) : printers[format](writer, data[0]));
}

function validateConcurrency(value = 10) {
    if (value < 1) throw Error("Concurrency must be greater than 0");
    return value;
}

async function handleResolvePromises(promises, bail) {
    if (bail) {
        let results = await Promise.all(promises);
        return results.flatMap((values)=>values);
    }
    let results1 = await Promise.allSettled(promises), errors = [], manifests = [];
    for (let result of results1)"fulfilled" === result.status ? manifests.push(...result.value) : errors.push(result.reason);
    if (errors.length) throw aggregateErrors(errors);
    return manifests;
}
async function resolve(value, options = {}) {
    let { validate =!0 , index =[] , path ="" , bail , concurrency  } = options, limit = pLimit(validateConcurrency(concurrency));
    function createResolveError(message, err) {
        return err instanceof ResolveError ? err : new ResolveError(message, {
            path,
            index,
            value,
            cause: err
        });
    }
    if ("function" == typeof value) try {
        return resolve(await value(), options);
    } catch (err) {
        throw createResolveError("Input function value thrown an error", err);
    }
    if (value instanceof Promise || value && ("function" == typeof value || "object" == typeof value) && "function" == typeof value.then) try {
        return resolve(await value, options);
    } catch (err1) {
        throw createResolveError("Input promise value rejected", err1);
    }
    if ("object" == typeof value && null != value && "function" == typeof value[Symbol.iterator]) {
        let promises = [], i = 0;
        try {
            for (let entry of value)promises.push(limit(()=>resolve(entry, {
                    ...options,
                    index: [
                        ...index,
                        i++
                    ]
                })));
        } catch (err2) {
            throw createResolveError("Input iterable value thrown an error", err2);
        }
        return handleResolvePromises(promises, bail);
    }
    if (isRecord(value) && "function" == typeof value[Symbol.asyncIterator]) {
        let promises1 = [], i1 = 0;
        try {
            for await (let entry1 of value)promises1.push(limit(()=>resolve(entry1, {
                    ...options,
                    index: [
                        ...index,
                        i1++
                    ]
                })));
        } catch (err3) {
            throw createResolveError("Input async iterable value thrown an error", err3);
        }
        return handleResolvePromises(promises1, bail);
    }
    if (validate && value && "function" == typeof value.validate) try {
        logger.log(LogLevel.Debug, `Validating manifests ${index.join(".")} in ${options.path}`), await value.validate();
    } catch (err4) {
        throw createResolveError("Validation error", err4);
    }
    return [
        {
            path,
            index,
            data: value
        }
    ];
}

function createMatcher(patterns, baseOptions) {
    let positivePatterns = [], negativePatterns = [];
    for (let pattern of patterns){
        let parsed = mm.parse(pattern, baseOptions);
        parsed.length && parsed[0].negated ? negativePatterns.push(parsed[0].consumed) : positivePatterns.push(pattern);
    }
    let options = {
        ...baseOptions,
        ignore: negativePatterns
    };
    return (path)=>mm.isMatch(path, positivePatterns, options);
}
async function readDir(path) {
    let files = await readdir(path, {
        withFileTypes: !0
    });
    return files.sort((a, b)=>a.name > b.name ? 1 : a.name < b.name ? -1 : 0);
}
async function* glob(options) {
    let matcherOptions = {
        cwd: options.path
    }, suffix = options.extensions.length > 1 ? `.{${options.extensions.join(",")}}` : `.${options.extensions.join(",")}`, dirMatcher = createMatcher(options.patterns, matcherOptions), fileMatcher = createMatcher(options.patterns.map((pattern)=>pattern + suffix), matcherOptions);
    async function* walk(path, parent) {
        for (let file of (await readDir(path))){
            let result = {
                relativePath: posix.join(parent, file.name),
                absolutePath: join(path, file.name)
            };
            file.isDirectory() ? (dirMatcher(result.relativePath) && (yield result), yield* walk(result.absolutePath, result.relativePath)) : fileMatcher(result.relativePath) && (yield result);
        }
    }
    yield* walk(options.path, "");
}

async function resolveComponentPath(path, extensions) {
    try {
        return await resolve$1(path, {
            extensions
        });
    } catch (err) {
        throw new GenerateError("Module path resolve failed", {
            path,
            cause: err
        });
    }
}
async function getComponentValue(path) {
    try {
        let mod = await importPath(path);
        return mod.default;
    } catch (err) {
        throw new GenerateError("Component value resolve failed", {
            path,
            cause: err
        });
    }
}
async function generate(options) {
    if (!options.components.length) throw new GenerateError("components must not be empty");
    let concurrency = validateConcurrency(options.concurrency), extensions = function(extensions = getRequireExtensions().map((ext)=>ext.substring(1))) {
        if (!extensions.length) throw new GenerateError("extensions must not be empty");
        for (let ext of extensions)if (ext.startsWith(".")) throw new GenerateError(`extension must not be started with ".": "${ext}"`);
        return extensions;
    }(options.extensions), extensionsWithDot = extensions.map((ext)=>"." + ext), promises = [], limit = pLimit(concurrency);
    async function resolveFile(file) {
        logger.log(LogLevel.Debug, `Found component "${file.relativePath}"`);
        let path = await resolveComponentPath(file.absolutePath, extensionsWithDot);
        return path ? resolve(await getComponentValue(path), {
            validate: options.validate,
            bail: options.bail,
            concurrency: options.concurrency,
            index: [],
            path
        }) : (logger.log(LogLevel.Debug, "Module not found", {
            data: {
                path: file.absolutePath,
                extensions: extensionsWithDot
            }
        }), []);
    }
    for await (let file of glob({
        path: options.path,
        extensions,
        patterns: options.components
    }))promises.push(limit(()=>resolveFile(file)));
    return {
        manifests: await handleResolvePromises(promises, options.bail)
    };
}

export { GenerateError, PrintFormat, ResolveError, generate, print, resolve };
//# sourceMappingURL=index.node.mjs.map
