{"version":3,"file":"index.node.mjs","sources":["../src/error.ts","../src/print.ts","../src/utils.ts","../src/resolve.ts","../src/glob.ts","../src/generate.ts"],"sourcesContent":["import AggregateError from \"@kosko/aggregate-error\";\nimport { isRecord } from \"@kosko/common-utils\";\nimport extractStack from \"extract-stack\";\n\nconst STACK_INDENT = \"    \";\n\ninterface Component {\n  apiVersion: string;\n  kind: string;\n  metadata: {\n    name: string;\n    namespace?: string;\n  };\n}\n\n/**\n * @public\n */\nexport interface ComponentInfo {\n  apiVersion: string;\n  kind: string;\n  name: string;\n  namespace?: string;\n}\n\nfunction isComponent(value: unknown): value is Component {\n  if (!isRecord(value)) return false;\n\n  const { apiVersion, kind, metadata } = value;\n\n  return (\n    typeof apiVersion === \"string\" &&\n    typeof kind === \"string\" &&\n    isRecord(metadata) &&\n    typeof metadata.name === \"string\"\n  );\n}\n\nexport function aggregateErrors(errors: unknown[]) {\n  if (errors.length === 1) {\n    return errors[0];\n  }\n\n  return new AggregateError(errors);\n}\n\nfunction decorateErrorStack(err: Error, values: Record<string, string>) {\n  const origStack = extractStack(err.stack);\n  err.stack = `${err.name}: ${err.message}`;\n\n  for (const [key, value] of Object.entries(values)) {\n    err.stack += `\\n${STACK_INDENT}${key}: ${value}`;\n  }\n\n  if (origStack) err.stack += \"\\n\" + origStack;\n}\n\nfunction generateCauseMessage(cause: unknown) {\n  if (typeof cause === \"string\") return cause;\n\n  if (isRecord(cause)) {\n    const { name, message, stack } = cause;\n\n    if (typeof message !== \"string\") {\n      return;\n    }\n\n    let result = `${(typeof name === \"string\" && name) || \"Error\"}: ${message}`;\n\n    if (typeof stack === \"string\") {\n      const extracted = extractStack(stack);\n\n      if (extracted) {\n        result +=\n          \"\\n\" +\n          extracted\n            .split(\"\\n\")\n            .map((line) => STACK_INDENT + line)\n            .join(\"\\n\");\n      }\n    }\n\n    return result;\n  }\n}\n\n/**\n * @public\n */\nexport interface ResolveErrorOptions {\n  path?: string;\n  index?: number[];\n  cause?: unknown;\n  value?: unknown;\n}\n\n/**\n * @public\n */\nexport class ResolveError extends Error {\n  public readonly path?: string;\n  public readonly index?: number[];\n  public readonly cause?: unknown;\n  public readonly value?: unknown;\n  public readonly component?: ComponentInfo;\n\n  public constructor(message: string, options: ResolveErrorOptions = {}) {\n    super(message);\n\n    this.path = options.path;\n    this.index = options.index;\n    this.cause = options.cause;\n    this.value = options.value;\n\n    if (isComponent(this.value)) {\n      this.component = {\n        apiVersion: this.value.apiVersion,\n        kind: this.value.kind,\n        name: this.value.metadata.name,\n        namespace: this.value.metadata.namespace\n      };\n    }\n\n    const cause = generateCauseMessage(this.cause);\n\n    decorateErrorStack(this, {\n      ...(this.path && { Path: this.path }),\n      ...(this.index?.length && { Index: `[${this.index.join(\", \")}]` }),\n      ...(this.component && {\n        Kind: `${this.component.apiVersion}/${this.component.kind}`,\n        ...(this.component.namespace && {\n          Namespace: this.component.namespace\n        }),\n        Name: this.component.name\n      }),\n      ...(cause && { Cause: cause })\n    });\n  }\n}\n\nResolveError.prototype.name = \"ResolveError\";\n\n/**\n * @public\n */\nexport interface GenerateErrorOptions {\n  path?: string;\n  cause?: unknown;\n}\n\n/**\n * @public\n */\nexport class GenerateError extends Error {\n  public readonly path?: string;\n  public readonly cause?: unknown;\n\n  constructor(message: string, options: GenerateErrorOptions = {}) {\n    super(message);\n\n    this.path = options.path;\n    this.cause = options.cause;\n\n    const cause = generateCauseMessage(this.cause);\n\n    decorateErrorStack(this, {\n      ...(this.path && { Path: this.path }),\n      ...(cause && { Cause: cause })\n    });\n  }\n}\n\nGenerateError.prototype.name = \"GenerateError\";\n","import yaml from \"js-yaml\";\nimport stringify from \"fast-safe-stringify\";\nimport { Result } from \"./base\";\n\n/**\n * @public\n */\nexport interface Writer {\n  write(data: string): void;\n}\n\n/**\n * @public\n */\nexport enum PrintFormat {\n  YAML = \"yaml\",\n  JSON = \"json\"\n}\n\n/**\n * @public\n */\nexport interface PrintOptions {\n  format: PrintFormat;\n  writer: Writer;\n}\n\ntype Printer<T> = (writer: Writer, data: T) => void;\ntype PrinterMap<T> = Record<PrintFormat, Printer<T>>;\n\nfunction stringifyYAML(data: unknown): string {\n  return yaml.dump(data, { noRefs: true });\n}\n\nfunction stringifyJSON(data: unknown): string {\n  return stringify(data, undefined, \"  \");\n}\n\nconst printers: PrinterMap<unknown> = {\n  [PrintFormat.YAML](writer, data) {\n    writer.write(stringifyYAML(data));\n  },\n  [PrintFormat.JSON](writer, data) {\n    writer.write(stringifyJSON(data));\n  }\n};\n\nconst arrPrinters: PrinterMap<unknown[]> = {\n  [PrintFormat.YAML](writer, data) {\n    for (const item of data) {\n      writer.write(\"---\\n\" + stringifyYAML(item));\n    }\n  },\n  [PrintFormat.JSON](writer, data) {\n    const list = { apiVersion: \"v1\", kind: \"List\", items: data };\n    writer.write(stringifyJSON(list));\n  }\n};\n\n/**\n * Prints `result` to a {@link Writer}.\n *\n * @public\n */\nexport function print(result: Result, { format, writer }: PrintOptions): void {\n  const data = result.manifests.map((manifest) => manifest.data);\n  if (!data.length) return;\n\n  if (data.length > 1) {\n    arrPrinters[format](writer, data);\n  } else {\n    printers[format](writer, data[0]);\n  }\n}\n","export function validateConcurrency(value = 10): number {\n  if (value < 1) {\n    throw new Error(\"Concurrency must be greater than 0\");\n  }\n\n  return value;\n}\n","import { Manifest } from \"./base\";\nimport logger, { LogLevel } from \"@kosko/log\";\nimport { aggregateErrors, ResolveError } from \"./error\";\nimport { isRecord } from \"@kosko/common-utils\";\nimport pLimit from \"p-limit\";\nimport { validateConcurrency } from \"./utils\";\n\ninterface Validator {\n  validate(): void | Promise<void>;\n}\n\nfunction isValidator(value: unknown): value is Validator {\n  return !!value && typeof (value as any).validate === \"function\";\n}\n\nfunction isPromiseLike(value: unknown): value is PromiseLike<unknown> {\n  if (value instanceof Promise) return true;\n\n  return (\n    !!value &&\n    (typeof value === \"function\" || typeof value === \"object\") &&\n    typeof (value as any).then === \"function\"\n  );\n}\n\nfunction isIterable(value: unknown): value is Iterable<unknown> {\n  return (\n    typeof value === \"object\" &&\n    value != null &&\n    typeof (value as any)[Symbol.iterator] === \"function\"\n  );\n}\n\nfunction isAsyncIterable(value: unknown): value is AsyncIterable<unknown> {\n  return isRecord(value) && typeof value[Symbol.asyncIterator] === \"function\";\n}\n\nexport async function handleResolvePromises(\n  promises: readonly Promise<Manifest[]>[],\n  bail?: boolean\n): Promise<Manifest[]> {\n  if (bail) {\n    const results = await Promise.all(promises);\n    return results.flatMap((values) => values);\n  }\n\n  const results = await Promise.allSettled(promises);\n  const errors: unknown[] = [];\n  const manifests: Manifest[] = [];\n\n  for (const result of results) {\n    if (result.status === \"fulfilled\") {\n      manifests.push(...result.value);\n    } else {\n      errors.push(result.reason);\n    }\n  }\n\n  if (errors.length) {\n    throw aggregateErrors(errors);\n  }\n\n  return manifests;\n}\n\n/**\n * @public\n */\nexport interface ResolveOptions {\n  /**\n   * Execute `validate` method of each values.\n   *\n   * @defaultValue `true`\n   */\n  validate?: boolean;\n\n  /**\n   * Source path of a manifest.\n   *\n   * @defaultValue `\"\"`\n   */\n  path?: string;\n\n  /**\n   * Source index of a manifest.\n   *\n   * @defaultValue `[]`\n   */\n  index?: number[];\n\n  /**\n   * Stop immediately when an error occurred.\n   *\n   * @defaultValue `false`\n   */\n  bail?: boolean;\n\n  /**\n   * Maximum number of concurrent tasks.\n   *\n   * @defaultValue `10`\n   */\n  concurrency?: number;\n}\n\n/**\n * Flattens the input value and validate each values.\n *\n * @remarks\n * The `value` can be an object, an array, a `Promise`, a function, an async\n * function, an iterable, or an async iterable.\n *\n * @throws {@link ResolveError}\n * Thrown if an error occurred.\n *\n * @throws {@link @kosko/aggregate-error#AggregateError}\n * Thrown if multiple errors occurred.\n *\n * @public\n */\nexport async function resolve(\n  value: unknown,\n  options: ResolveOptions = {}\n): Promise<Manifest[]> {\n  const { validate = true, index = [], path = \"\", bail, concurrency } = options;\n  const limit = pLimit(validateConcurrency(concurrency));\n\n  function createResolveError(message: string, err: unknown) {\n    if (err instanceof ResolveError) return err;\n\n    return new ResolveError(message, {\n      path,\n      index,\n      value,\n      cause: err\n    });\n  }\n\n  if (typeof value === \"function\") {\n    try {\n      return resolve(await value(), options);\n    } catch (err) {\n      throw createResolveError(\"Input function value thrown an error\", err);\n    }\n  }\n\n  if (isPromiseLike(value)) {\n    try {\n      return resolve(await value, options);\n    } catch (err) {\n      throw createResolveError(\"Input promise value rejected\", err);\n    }\n  }\n\n  if (isIterable(value)) {\n    const promises: Promise<Manifest[]>[] = [];\n    let i = 0;\n\n    try {\n      for (const entry of value) {\n        promises.push(\n          limit(() =>\n            resolve(entry, {\n              ...options,\n              index: [...index, i++]\n            })\n          )\n        );\n      }\n    } catch (err) {\n      throw createResolveError(\"Input iterable value thrown an error\", err);\n    }\n\n    return handleResolvePromises(promises, bail);\n  }\n\n  if (isAsyncIterable(value)) {\n    const promises: Promise<Manifest[]>[] = [];\n    let i = 0;\n\n    try {\n      for await (const entry of value) {\n        promises.push(\n          limit(() =>\n            resolve(entry, {\n              ...options,\n              index: [...index, i++]\n            })\n          )\n        );\n      }\n    } catch (err) {\n      throw createResolveError(\n        \"Input async iterable value thrown an error\",\n        err\n      );\n    }\n\n    return handleResolvePromises(promises, bail);\n  }\n\n  if (validate) {\n    if (isValidator(value)) {\n      try {\n        logger.log(\n          LogLevel.Debug,\n          `Validating manifests ${index.join(\".\")} in ${options.path}`\n        );\n        await value.validate();\n      } catch (err) {\n        throw createResolveError(\"Validation error\", err);\n      }\n    }\n  }\n\n  const manifest: Manifest = {\n    path,\n    index,\n    data: value\n  };\n\n  return [manifest];\n}\n","import { readdir } from \"node:fs/promises\";\nimport { join, posix } from \"node:path\";\nimport mm from \"micromatch\";\n\nfunction createMatcher(patterns: readonly string[], baseOptions: mm.Options) {\n  const positivePatterns: string[] = [];\n  const negativePatterns: string[] = [];\n\n  for (const pattern of patterns) {\n    const parsed = mm.parse(pattern, baseOptions) as [\n      { negated: boolean; consumed: string }\n    ];\n\n    if (parsed.length && parsed[0].negated) {\n      negativePatterns.push(parsed[0].consumed);\n    } else {\n      positivePatterns.push(pattern);\n    }\n  }\n\n  const options: mm.Options = {\n    ...baseOptions,\n    ignore: negativePatterns\n  };\n\n  return (path: string): boolean => {\n    return mm.isMatch(path, positivePatterns, options);\n  };\n}\n\nasync function readDir(path: string) {\n  const files = await readdir(path, { withFileTypes: true });\n\n  return files.sort((a, b) => {\n    if (a.name > b.name) {\n      return 1;\n    }\n\n    if (a.name < b.name) {\n      return -1;\n    }\n\n    return 0;\n  });\n}\n\nexport interface GlobOptions {\n  path: string;\n  patterns: readonly string[];\n  extensions: readonly string[];\n}\n\nexport interface GlobResult {\n  relativePath: string;\n  absolutePath: string;\n}\n\nexport async function* glob(options: GlobOptions): AsyncIterable<GlobResult> {\n  const matcherOptions: mm.Options = { cwd: options.path };\n  const suffix =\n    options.extensions.length > 1\n      ? `.{${options.extensions.join(\",\")}}`\n      : `.${options.extensions.join(\",\")}`;\n  const dirMatcher = createMatcher(options.patterns, matcherOptions);\n  const fileMatcher = createMatcher(\n    options.patterns.map((pattern) => pattern + suffix),\n    matcherOptions\n  );\n\n  async function* walk(\n    path: string,\n    parent: string\n  ): AsyncIterable<GlobResult> {\n    for (const file of await readDir(path)) {\n      const result: GlobResult = {\n        relativePath: posix.join(parent, file.name),\n        absolutePath: join(path, file.name)\n      };\n\n      if (file.isDirectory()) {\n        if (dirMatcher(result.relativePath)) {\n          yield result;\n        }\n\n        yield* walk(result.absolutePath, result.relativePath);\n      } else if (fileMatcher(result.relativePath)) {\n        yield result;\n      }\n    }\n  }\n\n  yield* walk(options.path, \"\");\n}\n","import {\n  importPath,\n  resolve as resolveModule,\n  getRequireExtensions\n} from \"@kosko/require\";\nimport type { Manifest, Result } from \"./base\";\nimport logger, { LogLevel } from \"@kosko/log\";\nimport { handleResolvePromises, resolve } from \"./resolve\";\nimport { GenerateError } from \"./error\";\nimport { glob, GlobResult } from \"./glob\";\nimport pLimit from \"p-limit\";\nimport { validateConcurrency } from \"./utils\";\n\n/**\n * @public\n */\nexport interface GenerateOptions {\n  /**\n   * Path of the component folder.\n   */\n  path: string;\n\n  /**\n   * Glob patterns of component names.\n   *\n   * @example\n   * ```js\n   * [\"*\"]\n   * ```\n   *\n   * @see {@link https://en.wikipedia.org/wiki/Glob_(programming) | glob pattern}\n   */\n  components: readonly string[];\n\n  /**\n   * File extensions of components.\n   *\n   * @example\n   * ```js\n   * [\"js\", \"json\"]\n   * ```\n   */\n  extensions?: readonly string[];\n\n  /**\n   * {@inheritDoc ResolveOptions.validate}\n   */\n  validate?: boolean;\n\n  /**\n   * {@inheritDoc ResolveOptions.bail}\n   */\n  bail?: boolean;\n\n  /**\n   * {@inheritDoc ResolveOptions.concurrency}\n   */\n  concurrency?: number;\n}\n\nasync function resolveComponentPath(\n  path: string,\n  extensions: readonly string[]\n) {\n  try {\n    return await resolveModule(path, { extensions });\n  } catch (err) {\n    throw new GenerateError(\"Module path resolve failed\", {\n      path,\n      cause: err\n    });\n  }\n}\n\nasync function getComponentValue(path: string): Promise<unknown> {\n  try {\n    const mod = await importPath(path);\n    return mod.default;\n  } catch (err) {\n    throw new GenerateError(\"Component value resolve failed\", {\n      path,\n      cause: err\n    });\n  }\n}\n\nfunction validateExtensions(\n  extensions: readonly string[] = getRequireExtensions().map((ext) =>\n    ext.substring(1)\n  )\n) {\n  if (!extensions.length) {\n    throw new GenerateError(\"extensions must not be empty\");\n  }\n\n  for (const ext of extensions) {\n    if (ext.startsWith(\".\")) {\n      throw new GenerateError(\n        `extension must not be started with \".\": \"${ext}\"`\n      );\n    }\n  }\n\n  return extensions;\n}\n\n/**\n * Finds components with glob patterns in the specified path and returns exported\n * values from each components.\n *\n * @remarks\n * Extension names is optional in `options.components` because it's appended\n * automatically. (e.g. `foo` =\\> `foo?(.{js,json})`)\n *\n * Extensions are from `require.extensions`. You can require `ts-node/register`\n * to add support for `.ts` extension.\n *\n * Note that this function currently is only available on Node.js.\n *\n * @throws {@link GenerateError}\n * Thrown if an error occurred.\n *\n * @throws {@link @kosko/aggregate-error#AggregateError}\n * Thrown if multiple errors occurred.\n *\n * @public\n * @see {@link resolve}\n */\nexport async function generate(options: GenerateOptions): Promise<Result> {\n  /* istanbul ignore next */\n  // eslint-disable-next-line no-restricted-globals\n  if (process.env.BUILD_TARGET === \"browser\") {\n    throw new Error(\"generate is only supported on Node.js and Deno\");\n  }\n\n  if (!options.components.length) {\n    throw new GenerateError(\"components must not be empty\");\n  }\n\n  const concurrency = validateConcurrency(options.concurrency);\n  const extensions = validateExtensions(options.extensions);\n  const extensionsWithDot = extensions.map((ext) => \".\" + ext);\n  const promises: Promise<Manifest[]>[] = [];\n  const limit = pLimit(concurrency);\n\n  async function resolveFile(file: GlobResult): Promise<Manifest[]> {\n    logger.log(LogLevel.Debug, `Found component \"${file.relativePath}\"`);\n\n    const path = await resolveComponentPath(\n      file.absolutePath,\n      extensionsWithDot\n    );\n\n    if (!path) {\n      logger.log(LogLevel.Debug, \"Module not found\", {\n        data: {\n          path: file.absolutePath,\n          extensions: extensionsWithDot\n        }\n      });\n\n      return [];\n    }\n\n    return resolve(await getComponentValue(path), {\n      validate: options.validate,\n      bail: options.bail,\n      concurrency: options.concurrency,\n      index: [],\n      path\n    });\n  }\n\n  for await (const file of glob({\n    path: options.path,\n    extensions,\n    patterns: options.components\n  })) {\n    promises.push(limit(() => resolveFile(file)));\n  }\n\n  return {\n    manifests: await handleResolvePromises(promises, options.bail)\n  };\n}\n"],"names":["STACK_INDENT","aggregateErrors","errors","length","AggregateError","decorateErrorStack","err","values","origStack","extractStack","stack","key","value","name","message","Object","entries","generateCauseMessage","cause","isRecord","result","extracted","split","map","line","join","ResolveError","Error","options","path","index","isComponent","apiVersion","kind","metadata","component","namespace","Path","Index","Kind","Namespace","Name","Cause","prototype","GenerateError","constructor","stringifyYAML","data","yaml","dump","noRefs","stringifyJSON","stringify","undefined","PrintFormat","YAML","JSON","printers","writer","write","arrPrinters","item","items","print","format","manifests","manifest","validateConcurrency","handleResolvePromises","promises","bail","results","Promise","all","flatMap","allSettled","status","push","reason","resolve","validate","concurrency","limit","pLimit","createResolveError","then","Symbol","iterator","i","entry","asyncIterator","logger","log","LogLevel","Debug","createMatcher","patterns","baseOptions","positivePatterns","negativePatterns","pattern","parsed","mm","parse","negated","consumed","ignore","isMatch","readDir","files","readdir","withFileTypes","sort","a","b","glob","matcherOptions","cwd","suffix","extensions","dirMatcher","fileMatcher","walk","parent","file","relativePath","posix","absolutePath","isDirectory","resolveComponentPath","resolveModule","getComponentValue","mod","importPath","default","generate","components","validateExtensions","getRequireExtensions","ext","substring","startsWith","extensionsWithDot","resolveFile"],"mappings":"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"}