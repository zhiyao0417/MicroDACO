import AggregateError from '@kosko/aggregate-error';
import { isRecord } from '@kosko/common-utils';
import extractStack from 'extract-stack';
import yaml from 'js-yaml';
import stringify from 'fast-safe-stringify';
import logger, { LogLevel } from '@kosko/log';
import pLimit from 'p-limit';

let STACK_INDENT = "    ";
function aggregateErrors(errors) {
    return 1 === errors.length ? errors[0] : new AggregateError(errors);
}
function decorateErrorStack(err, values) {
    let origStack = extractStack(err.stack);
    for (let [key, value] of (err.stack = `${err.name}: ${err.message}`, Object.entries(values)))err.stack += `\n${STACK_INDENT}${key}: ${value}`;
    origStack && (err.stack += "\n" + origStack);
}
function generateCauseMessage(cause) {
    if ("string" == typeof cause) return cause;
    if (isRecord(cause)) {
        let { name , message , stack  } = cause;
        if ("string" != typeof message) return;
        let result = `${"string" == typeof name && name || "Error"}: ${message}`;
        if ("string" == typeof stack) {
            let extracted = extractStack(stack);
            extracted && (result += "\n" + extracted.split("\n").map((line)=>STACK_INDENT + line).join("\n"));
        }
        return result;
    }
}
class ResolveError extends Error {
    constructor(message, options = {}){
        super(message), this.path = options.path, this.index = options.index, this.cause = options.cause, this.value = options.value, function(value) {
            if (!isRecord(value)) return !1;
            let { apiVersion , kind , metadata  } = value;
            return "string" == typeof apiVersion && "string" == typeof kind && isRecord(metadata) && "string" == typeof metadata.name;
        }(this.value) && (this.component = {
            apiVersion: this.value.apiVersion,
            kind: this.value.kind,
            name: this.value.metadata.name,
            namespace: this.value.metadata.namespace
        });
        let cause = generateCauseMessage(this.cause);
        decorateErrorStack(this, {
            ...this.path && {
                Path: this.path
            },
            ...this.index?.length && {
                Index: `[${this.index.join(", ")}]`
            },
            ...this.component && {
                Kind: `${this.component.apiVersion}/${this.component.kind}`,
                ...this.component.namespace && {
                    Namespace: this.component.namespace
                },
                Name: this.component.name
            },
            ...cause && {
                Cause: cause
            }
        });
    }
}
ResolveError.prototype.name = "ResolveError";
class GenerateError extends Error {
    constructor(message, options = {}){
        super(message), this.path = options.path, this.cause = options.cause;
        let cause = generateCauseMessage(this.cause);
        decorateErrorStack(this, {
            ...this.path && {
                Path: this.path
            },
            ...cause && {
                Cause: cause
            }
        });
    }
}
GenerateError.prototype.name = "GenerateError";

var PrintFormat;
function stringifyYAML(data) {
    return yaml.dump(data, {
        noRefs: !0
    });
}
function stringifyJSON(data) {
    return stringify(data, void 0, "  ");
}
!function(PrintFormat) {
    PrintFormat.YAML = "yaml", PrintFormat.JSON = "json";
}(PrintFormat || (PrintFormat = {}));
let printers = {
    [PrintFormat.YAML] (writer, data) {
        writer.write(stringifyYAML(data));
    },
    [PrintFormat.JSON] (writer, data) {
        writer.write(stringifyJSON(data));
    }
}, arrPrinters = {
    [PrintFormat.YAML] (writer, data) {
        for (let item of data)writer.write("---\n" + stringifyYAML(item));
    },
    [PrintFormat.JSON] (writer, data) {
        writer.write(stringifyJSON({
            apiVersion: "v1",
            kind: "List",
            items: data
        }));
    }
};
function print(result, { format , writer  }) {
    let data = result.manifests.map((manifest)=>manifest.data);
    data.length && (data.length > 1 ? arrPrinters[format](writer, data) : printers[format](writer, data[0]));
}

function validateConcurrency(value = 10) {
    if (value < 1) throw Error("Concurrency must be greater than 0");
    return value;
}

async function handleResolvePromises(promises, bail) {
    if (bail) {
        let results = await Promise.all(promises);
        return results.flatMap((values)=>values);
    }
    let results1 = await Promise.allSettled(promises), errors = [], manifests = [];
    for (let result of results1)"fulfilled" === result.status ? manifests.push(...result.value) : errors.push(result.reason);
    if (errors.length) throw aggregateErrors(errors);
    return manifests;
}
async function resolve(value, options = {}) {
    let { validate =!0 , index =[] , path ="" , bail , concurrency  } = options, limit = pLimit(validateConcurrency(concurrency));
    function createResolveError(message, err) {
        return err instanceof ResolveError ? err : new ResolveError(message, {
            path,
            index,
            value,
            cause: err
        });
    }
    if ("function" == typeof value) try {
        return resolve(await value(), options);
    } catch (err) {
        throw createResolveError("Input function value thrown an error", err);
    }
    if (value instanceof Promise || value && ("function" == typeof value || "object" == typeof value) && "function" == typeof value.then) try {
        return resolve(await value, options);
    } catch (err1) {
        throw createResolveError("Input promise value rejected", err1);
    }
    if ("object" == typeof value && null != value && "function" == typeof value[Symbol.iterator]) {
        let promises = [], i = 0;
        try {
            for (let entry of value)promises.push(limit(()=>resolve(entry, {
                    ...options,
                    index: [
                        ...index,
                        i++
                    ]
                })));
        } catch (err2) {
            throw createResolveError("Input iterable value thrown an error", err2);
        }
        return handleResolvePromises(promises, bail);
    }
    if (isRecord(value) && "function" == typeof value[Symbol.asyncIterator]) {
        let promises1 = [], i1 = 0;
        try {
            for await (let entry1 of value)promises1.push(limit(()=>resolve(entry1, {
                    ...options,
                    index: [
                        ...index,
                        i1++
                    ]
                })));
        } catch (err3) {
            throw createResolveError("Input async iterable value thrown an error", err3);
        }
        return handleResolvePromises(promises1, bail);
    }
    if (validate && value && "function" == typeof value.validate) try {
        logger.log(LogLevel.Debug, `Validating manifests ${index.join(".")} in ${options.path}`), await value.validate();
    } catch (err4) {
        throw createResolveError("Validation error", err4);
    }
    return [
        {
            path,
            index,
            data: value
        }
    ];
}

async function generate(options) {
    throw Error("generate is only supported on Node.js and Deno");
}

export { GenerateError, PrintFormat, ResolveError, generate, print, resolve };
//# sourceMappingURL=index.base.mjs.map
