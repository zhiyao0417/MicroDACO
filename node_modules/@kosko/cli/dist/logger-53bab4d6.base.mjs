import { ResolveError, GenerateError, print as print$1, generate } from '@kosko/generate';
import { join } from 'node:path';
import logger, { LogLevel, SilentLogWriter, logLevelFromString } from '@kosko/log';
import { exit, stderr, stdout } from 'node:process';
import jp from 'jsonpath';
import AggregateError from '@kosko/aggregate-error';
import cleanStack from 'clean-stack';
import extractStack from 'extract-stack';
import pc from 'picocolors';
import stringify from 'fast-safe-stringify';
import { isRecord } from '@kosko/common-utils';

class CLIError extends Error {
    constructor(msg, { output , code  } = {}){
        super(msg), this.output = output, this.code = code;
    }
}
CLIError.prototype.name = "CLIError";
function handleError(err) {
    let code = 1;
    err instanceof CLIError ? (null != err.code && (code = err.code), "string" == typeof err.output ? err.output && logger.log(LogLevel.Error, err.output) : logger.log(LogLevel.Error, err.message, {
        error: err
    })) : err instanceof Error ? "YError" !== err.name && logger.log(LogLevel.Error, "", {
        error: err
    }) : logger.log(LogLevel.Error, "", {
        error: err
    }), exit(code);
}

let parseRegexp = /^(.*?[^=<>~])=([^=<>~].*?$)/;
function parseKeyValuePair(s) {
    if ("string" != typeof s) throw Error(`The specified value "${s}" is not a string.`);
    let matches = s.match(parseRegexp);
    if (null == matches || 3 !== matches.length) throw Error(`Cannot parse string "${s}". Expected format is "<key>=<value>".`);
    return {
        key: matches[1],
        value: function(value) {
            try {
                return JSON.parse(value);
            } catch (e) {
                return value;
            }
        }(matches[2])
    };
}
function parseSetOptions(arg) {
    let result = [], argsArray = Array.isArray(arg) ? arg : [
        arg
    ];
    for (let argItem of argsArray)if ("object" == typeof argItem && null !== argItem) for (let argKey of Object.keys(argItem)){
        let argValues = argItem[argKey];
        for (let value of (Array.isArray(argValues) || (argValues = [
            argValues
        ]), argValues))result.push({
            ...parseKeyValuePair(value),
            componentName: argKey
        });
    }
    else result.push(parseKeyValuePair(argItem));
    return result;
}
function createCLIEnvReducer(setOptions) {
    for (let opt of setOptions)try {
        jp.parse(opt.key);
    } catch (err) {
        throw new CLIError(err.message, {
            code: 1,
            output: `Invalid JSONPath expression "${opt.key}": ${err.message}`
        });
    }
    let argsOrdered = setOptions.sort((a, b)=>a.componentName === b.componentName ? 0 : a.componentName ? 1 : -1);
    return {
        name: "cli",
        reduce (target, componentName) {
            for (let variable of argsOrdered){
                let isGlobalVariable = !variable.componentName;
                (isGlobalVariable || variable.componentName === componentName) && jp.apply(target, "$." + variable.key, ()=>variable.value);
            }
            return target;
        }
    };
}

async function importDefault(id) {
    let mod = await import(id);
    return mod.default;
}
async function importEnvGeneric() {
    return [
        await importDefault("@kosko/env")
    ];
}
async function setupEnv(config, args) {
    let cwd = args.cwd, envs = await importEnvGeneric(), paths = config.paths?.environment || {}, setReducer = args.set?.length ? createCLIEnvReducer(args.set) : void 0;
    for (let env of envs){
        var envs1;
        env.cwd = cwd, env.env = (envs1 = [
            config.baseEnvironment,
            args.env
        ].filter(Boolean)).length > 1 ? envs1 : envs1[0], config.extensions && (env.extensions = [
            ...config.extensions
        ]), paths.global && (env.paths.global = paths.global), paths.component && (env.paths.component = paths.component), setReducer && env.setReducers((reducers)=>[
                ...reducers,
                setReducer
            ]);
    }
}

var _pathErrorsMap;
function print(line) {
    stderr.write(line + "\n");
}
function getErrorCount(n) {
    return `${n} error${1 === n ? "" : "s"}`;
}
function toErrorLike(err) {
    if (err instanceof Error) return err;
    if (isRecord(err)) {
        let { name , message , stack  } = err;
        if ("string" == typeof message) return {
            name: "string" == typeof name && name || "Error",
            message,
            ..."string" == typeof stack && {
                stack
            }
        };
    }
    if ("string" == typeof err) return {
        name: "Error",
        message: err
    };
}
function getFormattedErrorTitle(err) {
    return "  " + pc.red(`âœ– ${err.name}: ${err.message}`);
}
function getFormattedErrorStack(err, extraIndent = "") {
    if ("string" != typeof err.stack) return;
    let stack = cleanStack(extractStack(err));
    return extraIndent && (stack = stack.split("\n").map((line)=>extraIndent + line).join("\n")), pc.gray(stack);
}
function stringifyResolveError(err) {
    let lines = [
        getFormattedErrorTitle(err)
    ];
    function appendMeta(name, value) {
        lines.push(`    ${name}: ${value}`);
    }
    if (err.index?.length && appendMeta("Index", `[${err.index.join(", ")}]`), err.component) {
        let { apiVersion , kind , name , namespace  } = err.component;
        appendMeta("Kind", `${apiVersion}/${kind}`), namespace && appendMeta("Namespace", namespace), appendMeta("Name", name);
    }
    let cause = function(cause) {
        if (isRecord(cause) && !0 === cause.ajv && !0 === cause.validation && Array.isArray(cause.errors)) return "\n" + cause.errors.map((err)=>{
            let msg;
            return `      ${msg = err.instancePath, err.message && (msg += ` ${err.message}`), "enum" === err.keyword && isRecord(err.params) && Array.isArray(err.params.allowedValues) && (msg += `: ${stringify(err.params.allowedValues)}`), msg}`;
        }).join("\n");
        let err = toErrorLike(cause);
        if (err) return [
            `    ${err.name}: ${err.message}`,
            getFormattedErrorStack(err, "  ")
        ].join("\n");
    }(err.cause);
    return cause && lines.push(cause), lines.join("\n");
}
function handleGenerateError(cwd, error, options) {
    let allErrors = function flattenError(err) {
        return err instanceof AggregateError ? err.errors.flatMap(flattenError) : [
            err
        ];
    }(error), pathErrorsMap = {}, unknownErrors = [];
    function pushToPathErrorsMap(path, value) {
        (_pathErrorsMap = pathErrorsMap)[path] ?? (_pathErrorsMap[path] = []), pathErrorsMap[path].push(value);
    }
    for (let err of allErrors)if (err instanceof ResolveError && err.path) pushToPathErrorsMap(err.path, stringifyResolveError(err));
    else if (err instanceof GenerateError && err.path) pushToPathErrorsMap(err.path, stringifyResolveError(err));
    else {
        let e = toErrorLike(err);
        e && unknownErrors.push(e);
    }
    for (let [path, errors] of Object.entries(pathErrorsMap)){
        var path1;
        for (let err1 of (print(`${pc.bold(((path1 = path).startsWith(cwd) && (path1 = path1.substring(cwd.length).replace(/^[/\\]+/, "")), path1.replace(/\\/g, "/")))} - ${getErrorCount(errors.length)}\n`), errors))print(err1 + "\n");
    }
    if (unknownErrors.length) for (let err2 of (print(pc.bold(`Other ${getErrorCount(unknownErrors.length)}\n`)), unknownErrors)){
        let stack = getFormattedErrorStack(err2);
        print(`${getFormattedErrorTitle(err2)}\n`), stack && print(`${stack}\n`);
    }
    return new CLIError("Generate failed", {
        output: `Generate failed (${options.bail ? "Only the first error is displayed because `bail` option is enabled" : `Total ${getErrorCount(allErrors.length)}`})`
    });
}

async function doGenerate({ cwd , ...options }) {
    try {
        return await generate({
            ...options,
            path: join(cwd, "components")
        });
    } catch (err) {
        throw handleGenerateError(cwd, err, options);
    }
}
async function handler(options) {
    let { printFormat , args , config , ignoreLoaders  } = options;
    await setupEnv(config, args);
    let result = await doGenerate({
        cwd: args.cwd,
        components: config.components,
        extensions: config.extensions,
        validate: args.validate,
        bail: config.bail,
        concurrency: config.concurrency
    });
    if (!result.manifests.length) throw new CLIError("No manifests are exported from components", {
        output: "No manifests are exported from components. Make sure there are exported manifests in components."
    });
    printFormat && print$1(result, {
        format: printFormat,
        writer: stdout
    });
}

function setupLogger(args) {
    if (args.silent) logger.setWriter(new SilentLogWriter());
    else {
        let level = args["log-level"];
        logger.setLevel(level && logLevelFromString(level) || LogLevel.Info);
    }
}

export { CLIError as C, handleError as a, handler as h, parseSetOptions as p, setupLogger as s };
//# sourceMappingURL=logger-53bab4d6.base.mjs.map
