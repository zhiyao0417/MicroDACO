import { resolve, join, sep, relative, dirname, isAbsolute } from 'node:path';
import yargs from 'yargs';
import { PrintFormat } from '@kosko/generate';
import { loadConfig as loadConfig$1, searchConfig, getConfig } from '@kosko/config';
import { C as CLIError, h as handler, p as parseSetOptions, s as setupLogger } from './logger-53bab4d6.base.mjs';
export { a as handleError } from './logger-53bab4d6.base.mjs';
import { readdir, access, stat, mkdir, writeFile, readFile } from 'node:fs/promises';
import pc from 'picocolors';
import logger, { LogLevel } from '@kosko/log';
import { getErrorCode, toArray } from '@kosko/common-utils';
import { migrateString, MigrateFormat } from '@kosko/migrate';
import getStdin from 'get-stdin';
import { stdout, cwd, argv } from 'node:process';
import 'jsonpath';
import '@kosko/aggregate-error';
import 'clean-stack';
import 'extract-stack';
import 'fast-safe-stringify';

function parse(input, argv) {
    return new Promise((resolve, reject)=>{
        input.parse(argv, {}, (err, args, output)=>{
            if (output && console.error(output), err) return reject(err);
            resolve();
        });
    });
}

async function loadConfig(args) {
    let base = args.config ? await loadConfig$1(resolve(args.cwd, args.config)) : await searchConfig(args.cwd), envs = [
        base.baseEnvironment,
        args.env
    ].filter((env)=>"string" == typeof env), { components , require , loaders  } = getConfig(base, envs), config = {
        ...base,
        components: args.components?.length ? args.components : components,
        require: [
            ...require,
            ...args.require || []
        ],
        loaders: [
            ...loaders,
            ...args.loader || []
        ],
        bail: args.bail ?? base.bail
    };
    if (!config.components.length) throw new CLIError("No components are given", {
        output: "No components are given. Set components in a config file or in arguments."
    });
    return config;
}

function generateBuilder(argv) {
    return argv.option("env", {
        type: "string",
        describe: "Environment name",
        alias: "e"
    }).option("config", {
        type: "string",
        describe: "Config path. Default to `kosko.toml` in current folder.",
        alias: "c"
    }).option("bail", {
        type: "boolean",
        describe: "Stop immediately when an error occurred."
    }).option("set", {
        type: "string",
        array: !0,
        describe: "Set values on the command line KEY=VAL (can be used multiple times)",
        alias: "s",
        coerce: parseSetOptions,
        default: []
    }).positional("components", {
        type: "string",
        array: !0,
        describe: "Components to generate. This overrides components set in config file."
    });
}
const generateCmd = {
    command: "generate [components..]",
    describe: "Generate Kubernetes manifests",
    builder: (argv)=>generateBuilder(argv).option("output", {
            type: "string",
            describe: "Output format",
            default: PrintFormat.YAML,
            choices: Object.values(PrintFormat),
            alias: "o"
        }).option("validate", {
            type: "boolean",
            describe: "Validate components",
            default: !0
        }).example("$0 generate", "Generate manifests").example("$0 generate foo bar", "Specify components").example("$0 generate foo_*", "Use glob pattern").example("$0 generate --env foo", "Set environment"),
    async handler (args) {
        let config = await loadConfig(args);
        await handler({
            printFormat: args.output,
            args,
            config
        });
    }
};

let IGNORE_FILES = [
    ".DS_Store",
    ".git",
    ".gitattributes",
    ".gitignore",
    ".hg",
    ".hgcheck",
    ".hgignore",
    ".idea",
    ".npmignore",
    "LICENSE",
    "Thumbs.db",
    ".yarn",
    /\.log$/,
    "node_modules",
    ".npm",
    ".cache"
];
async function isFolderEmpty(path) {
    let files = await readdir(path), filtered = files.filter((name)=>!IGNORE_FILES.some((pattern)=>"string" == typeof pattern ? name === pattern : pattern.test(name)));
    return !filtered.length;
}

async function fileExists(path) {
    try {
        return await access(path), !0;
    } catch  {
        return !1;
    }
}
async function detectPackageManager(cwd) {
    let [isYarn, isPnpm] = await Promise.all([
        "yarn.lock",
        "pnpm-lock.yaml"
    ].map((name)=>fileExists(join(cwd, name))));
    return isYarn ? "yarn" : isPnpm ? "pnpm" : "npm";
}

async function checkPath(path, force) {
    try {
        logger.log(LogLevel.Debug, `Checking stats of "${path}"`);
        let stats = await stat(path);
        if (!stats.isDirectory()) throw new CLIError("Destination already exists and is not a directory", {
            output: "Destination already exists and is not a directory. Please delete it or try another path."
        });
        if (force) return !0;
        if (await isFolderEmpty(path)) {
            logger.log(LogLevel.Trace, "Path can be initialized because it is empty");
            return;
        }
        throw new CLIError("Destination already exists", {
            output: 'Destination already exists. Please empty the directory or rerun with "--force" to proceed.'
        });
    } catch (err) {
        if ("ENOENT" !== getErrorCode(err)) throw err;
        logger.log(LogLevel.Trace, "Path can be initialized because it does not exist yet");
    }
}
async function writeFiles(path, files) {
    for (let file of files){
        let filePath = join(path, file.path);
        logger.log(LogLevel.Debug, `Writing file: "${file.path}"`), await mkdir(dirname(filePath), {
            recursive: !0
        }), await writeFile(filePath, file.content);
    }
}
const initCmd = {
    command: "init [path]",
    describe: "Set up a new Kosko directory",
    builder: (argv)=>argv.option("force", {
            type: "boolean",
            describe: "Overwrite existing files",
            alias: "f"
        }).positional("path", {
            type: "string",
            describe: "Path to initialize"
        }).example("$0 init", "Initialize in current directory").example("$0 init example", "Initialize in specified directory"),
    async handler (args) {
        let path = args.path ? resolve(args.cwd, args.path) : args.cwd;
        await checkPath(path, args.force), logger.log(LogLevel.Info, `Creating a Kosko project in "${path}"`);
        let template = (()=>{
            throw Error("Template is unavailable on current platform");
        })(), packageManager = args.packageManager ?? await detectPackageManager(path), runCmd = `${packageManager} run`, { dependencies , devDependencies , files  } = await template({
            path
        });
        await writeFiles(path, files);
        let cdPath = function(cwd, path) {
            if (cwd !== path) return path.startsWith(cwd + sep) ? relative(cwd, path) : path;
        }(args.cwd, path);
        logger.log(LogLevel.Info, `Project created at "${path}"

Inside that directory, you can run several commands:
${[
            [
                `${runCmd} generate`,
                "Validate components and generate Kubernetes manifests."
            ],
            [
                `${runCmd} validate`,
                "Only validate components."
            ]
        ].map(([cmd, desc])=>`\n  ${pc.cyan(cmd)}\n    ${desc}`).join("\n")}

We suggest that you begin by typing:

${[
            ...cdPath ? [
                `cd ${cdPath}`
            ] : [],
            `${runCmd} generate`
        ].filter(Boolean).map((line)=>`  ${pc.cyan(line)}`).join("\n")}`);
    }
};

const validateCmd = {
    command: "validate [components..]",
    describe: "Validate components",
    builder: (argv)=>generateBuilder(argv).example("$0 validate", "Validate components").example("$0 validate foo bar", "Specify components").example("$0 validate foo_*", "Use glob syntax"),
    async handler (args) {
        let config = await loadConfig(args);
        await handler({
            args: {
                ...args,
                validate: !0
            },
            config
        }), logger.log(LogLevel.Info, "Components are valid");
    }
};

function print(data) {
    return new Promise((resolve, reject)=>{
        stdout.write(data, (err)=>{
            if (err) return reject(err);
            resolve();
        });
    });
}

function concatFiles(arr) {
    if (!arr.length) return "";
    let output = "";
    for (let s of arr)s.startsWith("---") || (output += "---\n"), output += s + "\n";
    return output;
}
function readFileString(path) {
    return logger.log(LogLevel.Debug, `Reading file "${path}"`), readFile(path, "utf8");
}
async function readFilesInDir(dir) {
    logger.log(LogLevel.Debug, `Reading directory "${dir}"`);
    let files = await readdir(dir), contents = await Promise.all(files.map((file)=>readFileString(join(dir, file))));
    return concatFiles(contents);
}
const migrateCmd = {
    command: "migrate",
    describe: "Migrate YAML into components",
    builder: (argv)=>argv.option("filename", {
            type: "string",
            describe: "File, directory to migrate",
            required: !0,
            alias: "f"
        }).example("$0 migrate -f path/to/file", "Read from the path").example("$0 migrate -f -", "Read from stdin"),
    async handler (args) {
        var cwd;
        let file = concatFiles(await (cwd = args.cwd, Promise.all(toArray(args.filename).map(async (file)=>{
            if ("-" === file) return logger.log(LogLevel.Debug, "Reading from stdin"), getStdin();
            let path = resolve(cwd, file), stats = await stat(path);
            return stats.isDirectory() ? readFilesInDir(path) : readFileString(path);
        })))), content = await migrateString(file, {
            ...args.esm && {
                format: MigrateFormat.ESM
            }
        });
        await print(content);
    }
};

const version = "3.1.3";

function createRootCommand(args) {
    return yargs(args).scriptName("kosko").version(version).exitProcess(!1).option("cwd", {
        type: "string",
        describe: "Path of working directory",
        global: !0,
        default: cwd(),
        defaultDescription: "CWD",
        coerce: (arg)=>isAbsolute(arg) ? arg : resolve(arg)
    }).option("log-level", {
        type: "string",
        describe: "Set log level",
        global: !0,
        default: "info"
    }).option("silent", {
        type: "boolean",
        describe: "Disable log output",
        global: !0,
        default: !1
    }).group([
        "cwd",
        "log-level",
        "silent",
        "help",
        "version"
    ], "Global Options:").middleware(setupLogger).command(initCmd).command(generateCmd).command(validateCmd).command(migrateCmd).demandCommand();
}

async function run(args = argv.slice(2)) {
    await parse(createRootCommand(args), args);
}

export { run };
//# sourceMappingURL=index.base.mjs.map
