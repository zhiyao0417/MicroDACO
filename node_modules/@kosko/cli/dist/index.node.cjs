'use strict';

var node_path = require('node:path');
var yargs = require('yargs');
var generate = require('@kosko/generate');
var config = require('@kosko/config');
var logger = require('./logger-2b83e688.node.cjs');
var promises = require('node:fs/promises');
var pc = require('picocolors');
var logger$1 = require('@kosko/log');
var node_os = require('node:os');
var stringify = require('fast-safe-stringify');
var commonUtils = require('@kosko/common-utils');
var node_url = require('node:url');
var require$1 = require('@kosko/require');
var execUtils = require('@kosko/exec-utils');
var node_process = require('node:process');
var migrate = require('@kosko/migrate');
var getStdin = require('get-stdin');
require('jsonpath');
require('resolve-from');
require('pkg-up');
require('@kosko/aggregate-error');
require('clean-stack');
require('extract-stack');
require('node:module');

function _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }

var yargs__default = /*#__PURE__*/_interopDefault(yargs);
var pc__default = /*#__PURE__*/_interopDefault(pc);
var logger__default = /*#__PURE__*/_interopDefault(logger$1);
var stringify__default = /*#__PURE__*/_interopDefault(stringify);
var getStdin__default = /*#__PURE__*/_interopDefault(getStdin);

function parse(input, argv) {
    return new Promise((resolve, reject)=>{
        input.parse(argv, {}, (err, args, output)=>{
            if (output && console.error(output), err) return reject(err);
            resolve();
        });
    });
}

async function loadConfig(args) {
    let base = args.config ? await config.loadConfig(node_path.resolve(args.cwd, args.config)) : await config.searchConfig(args.cwd), envs = [
        base.baseEnvironment,
        args.env
    ].filter((env)=>"string" == typeof env), { components , require , loaders  } = config.getConfig(base, envs), config$1 = {
        ...base,
        components: args.components?.length ? args.components : components,
        require: [
            ...require,
            ...args.require || []
        ],
        loaders: [
            ...loaders,
            ...args.loader || []
        ],
        bail: args.bail ?? base.bail
    };
    if (!config$1.components.length) throw new logger.CLIError("No components are given", {
        output: "No components are given. Set components in a config file or in arguments."
    });
    return config$1;
}

function generateBuilder(argv) {
    return argv.option("env", {
        type: "string",
        describe: "Environment name",
        alias: "e"
    }).option("config", {
        type: "string",
        describe: "Config path. Default to `kosko.toml` in current folder.",
        alias: "c"
    }).option("bail", {
        type: "boolean",
        describe: "Stop immediately when an error occurred."
    }).option("set", {
        type: "string",
        array: !0,
        describe: "Set values on the command line KEY=VAL (can be used multiple times)",
        alias: "s",
        coerce: logger.parseSetOptions,
        default: []
    }).positional("components", {
        type: "string",
        array: !0,
        describe: "Components to generate. This overrides components set in config file."
    }).option("require", {
        type: "string",
        array: !0,
        describe: "Require modules. Modules set in config file will also be required.",
        alias: "r"
    }).option("loader", {
        type: "string",
        array: !0,
        describe: "Module loader. Loaders set in config file will also be loaded."
    });
}
const generateCmd = {
    command: "generate [components..]",
    describe: "Generate Kubernetes manifests",
    builder: (argv)=>generateBuilder(argv).option("output", {
            type: "string",
            describe: "Output format",
            default: generate.PrintFormat.YAML,
            choices: Object.values(generate.PrintFormat),
            alias: "o"
        }).option("validate", {
            type: "boolean",
            describe: "Validate components",
            default: !0
        }).example("$0 generate", "Generate manifests").example("$0 generate foo bar", "Specify components").example("$0 generate foo_*", "Use glob pattern").example("$0 generate --env foo", "Set environment"),
    async handler (args) {
        let config = await loadConfig(args);
        await logger.handler({
            printFormat: args.output,
            args,
            config
        });
    }
};

let IGNORE_FILES = [
    ".DS_Store",
    ".git",
    ".gitattributes",
    ".gitignore",
    ".hg",
    ".hgcheck",
    ".hgignore",
    ".idea",
    ".npmignore",
    "LICENSE",
    "Thumbs.db",
    ".yarn",
    /\.log$/,
    "node_modules",
    ".npm",
    ".cache"
];
async function isFolderEmpty(path) {
    let files = await promises.readdir(path), filtered = files.filter((name)=>!IGNORE_FILES.some((pattern)=>"string" == typeof pattern ? name === pattern : pattern.test(name)));
    return !filtered.length;
}

function generateKoskoConfig(additionalConfig) {
    return {
        path: "kosko.toml",
        content: [
            'components = ["*"]',
            ...additionalConfig ? [
                additionalConfig
            ] : []
        ].join(node_os.EOL) + node_os.EOL
    };
}

async function readJson(path) {
    try {
        let content = await promises.readFile(path, "utf8");
        return JSON.parse(content);
    } catch (err) {
        if ("ENOENT" !== commonUtils.getErrorCode(err)) throw err;
        return {};
    }
}
async function generatePackageJson(ctx, data = {}) {
    let path = node_path.join(ctx.path, "package.json");
    logger__default.default.log(logger$1.LogLevel.Debug, `Reading existing package.json from "${path}"`);
    let base = await readJson(path);
    return {
        path: "package.json",
        content: stringify__default.default({
            ...base,
            ...data,
            scripts: {
                ...base.scripts,
                generate: "kosko generate",
                validate: "kosko validate",
                ...data.scripts
            }
        }, void 0, "  ") + node_os.EOL
    };
}

let TEMPLATE_DIR = node_path.join(node_url.fileURLToPath(new URL(`file:${__filename}`).href), "../../templates");
async function generateFromTemplateFile(path, template = path) {
    return {
        path,
        content: await promises.readFile(node_path.join(TEMPLATE_DIR, template), "utf8")
    };
}
function generateReadme() {
    return generateFromTemplateFile("README.md");
}

let TEMPLATE_FILES$1 = [
    "components/nginx",
    "environments/dev/index",
    "environments/dev/nginx"
];
const baseDependencies = [
    "@kosko/env",
    "kosko",
    "kubernetes-models"
];
let cjsTemplate = async (ctx)=>({
        dependencies: baseDependencies,
        files: [
            await generatePackageJson(ctx),
            generateKoskoConfig(),
            await generateReadme(),
            ...await Promise.all(TEMPLATE_FILES$1.map((file)=>generateFromTemplateFile(`${file}.js`, `cjs/${file}.js`)))
        ]
    });
var cjsTemplate$1 = cjsTemplate;

let BASE_TSCONFIG = "@tsconfig/node14";
const tsDevDependencies = [
    "ts-node",
    "typescript",
    BASE_TSCONFIG
];
function generateTsConfig({ compilerOptions , ...data } = {}) {
    return {
        path: "tsconfig.json",
        content: stringify__default.default({
            extends: `${BASE_TSCONFIG}/tsconfig.json`,
            compilerOptions: {
                typeRoots: [
                    "./node_modules/@types",
                    "./typings"
                ],
                ...compilerOptions
            },
            ...data
        }, void 0, "  ") + node_os.EOL
    };
}
function generateTsEnvFiles() {
    return Promise.all([
        generateFromTemplateFile("environments/dev/index.ts", "ts/environments/dev/index.ts"),
        generateFromTemplateFile("environments/dev/nginx.ts", "ts/environments/dev/nginx.ts")
    ]);
}
let tsTemplate = async (ctx)=>({
        dependencies: baseDependencies,
        devDependencies: tsDevDependencies,
        files: [
            await generatePackageJson(ctx),
            generateKoskoConfig('require = ["ts-node/register"]'),
            await generateReadme(),
            generateTsConfig(),
            await generateFromTemplateFile("components/nginx.ts", "ts/components/nginx.ts"),
            ...await generateTsEnvFiles(),
            await generateFromTemplateFile("typings/@kosko__env/index.d.ts", "ts/typings/kosko-env.d.cts")
        ]
    });
var tsTemplate$1 = tsTemplate;

let TEMPLATE_FILES = [
    "components/nginx",
    "environments/dev/index",
    "environments/dev/nginx"
], esmTemplate = async (ctx)=>({
        dependencies: baseDependencies,
        files: [
            await generatePackageJson(ctx, {
                type: "module"
            }),
            generateKoskoConfig(),
            await generateReadme(),
            ...await Promise.all(TEMPLATE_FILES.map((file)=>generateFromTemplateFile(`${file}.js`, `esm/${file}.js`)))
        ]
    });
var esmTemplate$1 = esmTemplate;

let tsEsmTemplate = async (ctx)=>{
    let extensions = [
        "ts",
        "mts",
        ...require$1.getRequireExtensions().map((x)=>x.substring(1))
    ].map((x)=>`"${x}"`).join(", ");
    return {
        dependencies: baseDependencies,
        devDependencies: tsDevDependencies,
        files: [
            await generatePackageJson(ctx, {
                type: "module"
            }),
            generateKoskoConfig(`loaders = ["ts-node/esm"]
extensions = [${extensions}]`),
            await generateReadme(),
            generateTsConfig({
                compilerOptions: {
                    module: "nodenext",
                    moduleResolution: "nodenext"
                }
            }),
            await generateFromTemplateFile("components/nginx.ts", "esm/components/nginx.js"),
            ...await generateTsEnvFiles(),
            await generateFromTemplateFile("typings/@kosko__env/index.d.ts", "ts/typings/kosko-env.d.mts")
        ]
    };
};
var tsEsmTemplate$1 = tsEsmTemplate;

async function fileExists(path) {
    try {
        return await promises.access(path), !0;
    } catch  {
        return !1;
    }
}
async function detectPackageManager(cwd) {
    let [isYarn, isPnpm] = await Promise.all([
        "yarn.lock",
        "pnpm-lock.yaml"
    ].map((name)=>fileExists(node_path.join(cwd, name))));
    return isYarn ? "yarn" : isPnpm ? "pnpm" : "npm";
}
function getInstallCommand({ packageManager , dependencies , dev  }) {
    let isYarn = "yarn" === packageManager;
    return [
        packageManager,
        isYarn ? "add" : "install",
        ...dependencies,
        ...dev ? [
            isYarn ? "--dev" : "--save-dev"
        ] : []
    ];
}
async function installDependencies({ cwd , dependencies , packageManager , dev  }) {
    logger__default.default.log(logger$1.LogLevel.Info, `Installing ${dev ? "dev " : ""}dependencies: ${dependencies.map((x)=>pc__default.default.cyan(x)).join(", ")}`);
    let [name, ...args] = getInstallCommand({
        dependencies,
        packageManager,
        dev
    });
    await execUtils.spawn(name, args, {
        stdio: "inherit",
        cwd,
        env: {
            ...node_process.env,
            ADBLOCK: "1",
            DISABLE_OPENCOLLECTIVE: "1"
        }
    });
}

async function checkPath(path, force) {
    try {
        logger__default.default.log(logger$1.LogLevel.Debug, `Checking stats of "${path}"`);
        let stats = await promises.stat(path);
        if (!stats.isDirectory()) throw new logger.CLIError("Destination already exists and is not a directory", {
            output: "Destination already exists and is not a directory. Please delete it or try another path."
        });
        if (force) return !0;
        if (await isFolderEmpty(path)) {
            logger__default.default.log(logger$1.LogLevel.Trace, "Path can be initialized because it is empty");
            return;
        }
        throw new logger.CLIError("Destination already exists", {
            output: 'Destination already exists. Please empty the directory or rerun with "--force" to proceed.'
        });
    } catch (err) {
        if ("ENOENT" !== commonUtils.getErrorCode(err)) throw err;
        logger__default.default.log(logger$1.LogLevel.Trace, "Path can be initialized because it does not exist yet");
    }
}
async function writeFiles(path, files) {
    for (let file of files){
        let filePath = node_path.join(path, file.path);
        logger__default.default.log(logger$1.LogLevel.Debug, `Writing file: "${file.path}"`), await promises.mkdir(node_path.dirname(filePath), {
            recursive: !0
        }), await promises.writeFile(filePath, file.content);
    }
}
const initCmd = {
    command: "init [path]",
    describe: "Set up a new Kosko directory",
    builder: (argv)=>argv.option("force", {
            type: "boolean",
            describe: "Overwrite existing files",
            alias: "f"
        }).positional("path", {
            type: "string",
            describe: "Path to initialize"
        }).example("$0 init", "Initialize in current directory").example("$0 init example", "Initialize in specified directory").option("typescript", {
            type: "boolean",
            describe: "Generate TypeScript files",
            alias: "ts"
        }).option("esm", {
            type: "boolean",
            describe: "Generate ECMAScript module (ESM) files"
        }).option("install", {
            type: "boolean",
            describe: "Install dependencies automatically",
            default: !0
        }).option("package-manager", {
            type: "string",
            describe: "Package manager (npm, yarn, pnpm)",
            alias: "pm"
        }).example("$0 init --typescript", "Setup a TypeScript project"),
    async handler (args) {
        let path = args.path ? node_path.resolve(args.cwd, args.path) : args.cwd;
        await checkPath(path, args.force), logger__default.default.log(logger$1.LogLevel.Info, `Creating a Kosko project in "${path}"`);
        let template = args.typescript ? args.esm ? tsEsmTemplate$1 : tsTemplate$1 : args.esm ? esmTemplate$1 : cjsTemplate$1, packageManager = args.packageManager ?? await detectPackageManager(path), runCmd = `${packageManager} run`, { dependencies , devDependencies , files  } = await template({
            path
        });
        await writeFiles(path, files);
        let cdPath = function(cwd, path) {
            if (cwd !== path) return path.startsWith(cwd + node_path.sep) ? node_path.relative(cwd, path) : path;
        }(args.cwd, path), installSuccessful = !1;
        if (args.install) try {
            dependencies?.length && await installDependencies({
                cwd: path,
                packageManager,
                dependencies
            }), devDependencies?.length && await installDependencies({
                cwd: path,
                packageManager,
                dependencies: devDependencies,
                dev: !0
            }), installSuccessful = !0;
        } catch (err) {
            logger__default.default.log(logger$1.LogLevel.Warn, "Install failed", {
                error: err
            });
        }
        logger__default.default.log(logger$1.LogLevel.Info, `Project created at "${path}"

Inside that directory, you can run several commands:
${[
            [
                `${runCmd} generate`,
                "Validate components and generate Kubernetes manifests."
            ],
            [
                `${runCmd} validate`,
                "Only validate components."
            ]
        ].map(([cmd, desc])=>`\n  ${pc__default.default.cyan(cmd)}\n    ${desc}`).join("\n")}

We suggest that you begin by typing:

${[
            ...cdPath ? [
                `cd ${cdPath}`
            ] : [],
            ...args.install && installSuccessful ? [] : [
                dependencies?.length ? getInstallCommand({
                    packageManager,
                    dependencies
                }).join(" ") : "",
                devDependencies?.length ? getInstallCommand({
                    packageManager,
                    dependencies: devDependencies,
                    dev: !0
                }).join(" ") : ""
            ],
            `${runCmd} generate`
        ].filter(Boolean).map((line)=>`  ${pc__default.default.cyan(line)}`).join("\n")}`);
    }
};

const validateCmd = {
    command: "validate [components..]",
    describe: "Validate components",
    builder: (argv)=>generateBuilder(argv).example("$0 validate", "Validate components").example("$0 validate foo bar", "Specify components").example("$0 validate foo_*", "Use glob syntax"),
    async handler (args) {
        let config = await loadConfig(args);
        await logger.handler({
            args: {
                ...args,
                validate: !0
            },
            config
        }), logger__default.default.log(logger$1.LogLevel.Info, "Components are valid");
    }
};

function print(data) {
    return new Promise((resolve, reject)=>{
        node_process.stdout.write(data, (err)=>{
            if (err) return reject(err);
            resolve();
        });
    });
}

function concatFiles(arr) {
    if (!arr.length) return "";
    let output = "";
    for (let s of arr)s.startsWith("---") || (output += "---\n"), output += s + "\n";
    return output;
}
function readFileString(path) {
    return logger__default.default.log(logger$1.LogLevel.Debug, `Reading file "${path}"`), promises.readFile(path, "utf8");
}
async function readFilesInDir(dir) {
    logger__default.default.log(logger$1.LogLevel.Debug, `Reading directory "${dir}"`);
    let files = await promises.readdir(dir), contents = await Promise.all(files.map((file)=>readFileString(node_path.join(dir, file))));
    return concatFiles(contents);
}
const migrateCmd = {
    command: "migrate",
    describe: "Migrate YAML into components",
    builder: (argv)=>argv.option("filename", {
            type: "string",
            describe: "File, directory to migrate",
            required: !0,
            alias: "f"
        }).example("$0 migrate -f path/to/file", "Read from the path").example("$0 migrate -f -", "Read from stdin").option("esm", {
            type: "boolean",
            describe: "Generate ECMAScript module (ESM) files"
        }),
    async handler (args) {
        var cwd;
        let file = concatFiles(await (cwd = args.cwd, Promise.all(commonUtils.toArray(args.filename).map(async (file)=>{
            if ("-" === file) return logger__default.default.log(logger$1.LogLevel.Debug, "Reading from stdin"), getStdin__default.default();
            let path = node_path.resolve(cwd, file), stats = await promises.stat(path);
            return stats.isDirectory() ? readFilesInDir(path) : readFileString(path);
        })))), content = await migrate.migrateString(file, {
            ...args.esm && {
                format: migrate.MigrateFormat.ESM
            }
        });
        await print(content);
    }
};

const version = "3.1.3";

function createRootCommand(args) {
    return yargs__default.default(args).scriptName("kosko").version(version).exitProcess(!1).option("cwd", {
        type: "string",
        describe: "Path of working directory",
        global: !0,
        default: node_process.cwd(),
        defaultDescription: "CWD",
        coerce: (arg)=>node_path.isAbsolute(arg) ? arg : node_path.resolve(arg)
    }).option("log-level", {
        type: "string",
        describe: "Set log level",
        global: !0,
        default: "info"
    }).option("silent", {
        type: "boolean",
        describe: "Disable log output",
        global: !0,
        default: !1
    }).group([
        "cwd",
        "log-level",
        "silent",
        "help",
        "version"
    ], "Global Options:").middleware(logger.setupLogger).command(initCmd).command(generateCmd).command(validateCmd).command(migrateCmd).demandCommand();
}

async function run(args = node_process.argv.slice(2)) {
    await parse(createRootCommand(args), args);
}

exports.handleError = logger.handleError;
exports.run = run;
//# sourceMappingURL=index.node.cjs.map
