import { resolve, join, sep, relative, dirname, isAbsolute } from 'node:path';
import yargs from 'yargs';
import { PrintFormat } from '@kosko/generate';
import { loadConfig as loadConfig$1, searchConfig, getConfig } from '@kosko/config';
import { C as CLIError, h as handler, p as parseSetOptions, s as setupLogger } from './logger-abe09e60.node.mjs';
export { a as handleError } from './logger-abe09e60.node.mjs';
import { readdir, readFile, access, stat, mkdir, writeFile } from 'node:fs/promises';
import pc from 'picocolors';
import logger, { LogLevel } from '@kosko/log';
import { EOL } from 'node:os';
import stringify from 'fast-safe-stringify';
import { getErrorCode, toArray } from '@kosko/common-utils';
import { fileURLToPath } from 'node:url';
import { getRequireExtensions } from '@kosko/require';
import { spawn } from '@kosko/exec-utils';
import { env, stdout, cwd, argv } from 'node:process';
import { migrateString, MigrateFormat } from '@kosko/migrate';
import getStdin from 'get-stdin';
import 'jsonpath';
import 'resolve-from';
import 'pkg-up';
import '@kosko/aggregate-error';
import 'clean-stack';
import 'extract-stack';
import 'node:module';

function parse(input, argv) {
    return new Promise((resolve, reject)=>{
        input.parse(argv, {}, (err, args, output)=>{
            if (output && console.error(output), err) return reject(err);
            resolve();
        });
    });
}

async function loadConfig(args) {
    let base = args.config ? await loadConfig$1(resolve(args.cwd, args.config)) : await searchConfig(args.cwd), envs = [
        base.baseEnvironment,
        args.env
    ].filter((env)=>"string" == typeof env), { components , require , loaders  } = getConfig(base, envs), config = {
        ...base,
        components: args.components?.length ? args.components : components,
        require: [
            ...require,
            ...args.require || []
        ],
        loaders: [
            ...loaders,
            ...args.loader || []
        ],
        bail: args.bail ?? base.bail
    };
    if (!config.components.length) throw new CLIError("No components are given", {
        output: "No components are given. Set components in a config file or in arguments."
    });
    return config;
}

function generateBuilder(argv) {
    return argv.option("env", {
        type: "string",
        describe: "Environment name",
        alias: "e"
    }).option("config", {
        type: "string",
        describe: "Config path. Default to `kosko.toml` in current folder.",
        alias: "c"
    }).option("bail", {
        type: "boolean",
        describe: "Stop immediately when an error occurred."
    }).option("set", {
        type: "string",
        array: !0,
        describe: "Set values on the command line KEY=VAL (can be used multiple times)",
        alias: "s",
        coerce: parseSetOptions,
        default: []
    }).positional("components", {
        type: "string",
        array: !0,
        describe: "Components to generate. This overrides components set in config file."
    }).option("require", {
        type: "string",
        array: !0,
        describe: "Require modules. Modules set in config file will also be required.",
        alias: "r"
    }).option("loader", {
        type: "string",
        array: !0,
        describe: "Module loader. Loaders set in config file will also be loaded."
    });
}
const generateCmd = {
    command: "generate [components..]",
    describe: "Generate Kubernetes manifests",
    builder: (argv)=>generateBuilder(argv).option("output", {
            type: "string",
            describe: "Output format",
            default: PrintFormat.YAML,
            choices: Object.values(PrintFormat),
            alias: "o"
        }).option("validate", {
            type: "boolean",
            describe: "Validate components",
            default: !0
        }).example("$0 generate", "Generate manifests").example("$0 generate foo bar", "Specify components").example("$0 generate foo_*", "Use glob pattern").example("$0 generate --env foo", "Set environment"),
    async handler (args) {
        let config = await loadConfig(args);
        await handler({
            printFormat: args.output,
            args,
            config
        });
    }
};

let IGNORE_FILES = [
    ".DS_Store",
    ".git",
    ".gitattributes",
    ".gitignore",
    ".hg",
    ".hgcheck",
    ".hgignore",
    ".idea",
    ".npmignore",
    "LICENSE",
    "Thumbs.db",
    ".yarn",
    /\.log$/,
    "node_modules",
    ".npm",
    ".cache"
];
async function isFolderEmpty(path) {
    let files = await readdir(path), filtered = files.filter((name)=>!IGNORE_FILES.some((pattern)=>"string" == typeof pattern ? name === pattern : pattern.test(name)));
    return !filtered.length;
}

function generateKoskoConfig(additionalConfig) {
    return {
        path: "kosko.toml",
        content: [
            'components = ["*"]',
            ...additionalConfig ? [
                additionalConfig
            ] : []
        ].join(EOL) + EOL
    };
}

async function readJson(path) {
    try {
        let content = await readFile(path, "utf8");
        return JSON.parse(content);
    } catch (err) {
        if ("ENOENT" !== getErrorCode(err)) throw err;
        return {};
    }
}
async function generatePackageJson(ctx, data = {}) {
    let path = join(ctx.path, "package.json");
    logger.log(LogLevel.Debug, `Reading existing package.json from "${path}"`);
    let base = await readJson(path);
    return {
        path: "package.json",
        content: stringify({
            ...base,
            ...data,
            scripts: {
                ...base.scripts,
                generate: "kosko generate",
                validate: "kosko validate",
                ...data.scripts
            }
        }, void 0, "  ") + EOL
    };
}

let TEMPLATE_DIR = join(fileURLToPath(import.meta.url), "../../templates");
async function generateFromTemplateFile(path, template = path) {
    return {
        path,
        content: await readFile(join(TEMPLATE_DIR, template), "utf8")
    };
}
function generateReadme() {
    return generateFromTemplateFile("README.md");
}

let TEMPLATE_FILES$1 = [
    "components/nginx",
    "environments/dev/index",
    "environments/dev/nginx"
];
const baseDependencies = [
    "@kosko/env",
    "kosko",
    "kubernetes-models"
];
let cjsTemplate = async (ctx)=>({
        dependencies: baseDependencies,
        files: [
            await generatePackageJson(ctx),
            generateKoskoConfig(),
            await generateReadme(),
            ...await Promise.all(TEMPLATE_FILES$1.map((file)=>generateFromTemplateFile(`${file}.js`, `cjs/${file}.js`)))
        ]
    });
var cjsTemplate$1 = cjsTemplate;

let BASE_TSCONFIG = "@tsconfig/node14";
const tsDevDependencies = [
    "ts-node",
    "typescript",
    BASE_TSCONFIG
];
function generateTsConfig({ compilerOptions , ...data } = {}) {
    return {
        path: "tsconfig.json",
        content: stringify({
            extends: `${BASE_TSCONFIG}/tsconfig.json`,
            compilerOptions: {
                typeRoots: [
                    "./node_modules/@types",
                    "./typings"
                ],
                ...compilerOptions
            },
            ...data
        }, void 0, "  ") + EOL
    };
}
function generateTsEnvFiles() {
    return Promise.all([
        generateFromTemplateFile("environments/dev/index.ts", "ts/environments/dev/index.ts"),
        generateFromTemplateFile("environments/dev/nginx.ts", "ts/environments/dev/nginx.ts")
    ]);
}
let tsTemplate = async (ctx)=>({
        dependencies: baseDependencies,
        devDependencies: tsDevDependencies,
        files: [
            await generatePackageJson(ctx),
            generateKoskoConfig('require = ["ts-node/register"]'),
            await generateReadme(),
            generateTsConfig(),
            await generateFromTemplateFile("components/nginx.ts", "ts/components/nginx.ts"),
            ...await generateTsEnvFiles(),
            await generateFromTemplateFile("typings/@kosko__env/index.d.ts", "ts/typings/kosko-env.d.cts")
        ]
    });
var tsTemplate$1 = tsTemplate;

let TEMPLATE_FILES = [
    "components/nginx",
    "environments/dev/index",
    "environments/dev/nginx"
], esmTemplate = async (ctx)=>({
        dependencies: baseDependencies,
        files: [
            await generatePackageJson(ctx, {
                type: "module"
            }),
            generateKoskoConfig(),
            await generateReadme(),
            ...await Promise.all(TEMPLATE_FILES.map((file)=>generateFromTemplateFile(`${file}.js`, `esm/${file}.js`)))
        ]
    });
var esmTemplate$1 = esmTemplate;

let tsEsmTemplate = async (ctx)=>{
    let extensions = [
        "ts",
        "mts",
        ...getRequireExtensions().map((x)=>x.substring(1))
    ].map((x)=>`"${x}"`).join(", ");
    return {
        dependencies: baseDependencies,
        devDependencies: tsDevDependencies,
        files: [
            await generatePackageJson(ctx, {
                type: "module"
            }),
            generateKoskoConfig(`loaders = ["ts-node/esm"]
extensions = [${extensions}]`),
            await generateReadme(),
            generateTsConfig({
                compilerOptions: {
                    module: "nodenext",
                    moduleResolution: "nodenext"
                }
            }),
            await generateFromTemplateFile("components/nginx.ts", "esm/components/nginx.js"),
            ...await generateTsEnvFiles(),
            await generateFromTemplateFile("typings/@kosko__env/index.d.ts", "ts/typings/kosko-env.d.mts")
        ]
    };
};
var tsEsmTemplate$1 = tsEsmTemplate;

async function fileExists(path) {
    try {
        return await access(path), !0;
    } catch  {
        return !1;
    }
}
async function detectPackageManager(cwd) {
    let [isYarn, isPnpm] = await Promise.all([
        "yarn.lock",
        "pnpm-lock.yaml"
    ].map((name)=>fileExists(join(cwd, name))));
    return isYarn ? "yarn" : isPnpm ? "pnpm" : "npm";
}
function getInstallCommand({ packageManager , dependencies , dev  }) {
    let isYarn = "yarn" === packageManager;
    return [
        packageManager,
        isYarn ? "add" : "install",
        ...dependencies,
        ...dev ? [
            isYarn ? "--dev" : "--save-dev"
        ] : []
    ];
}
async function installDependencies({ cwd , dependencies , packageManager , dev  }) {
    logger.log(LogLevel.Info, `Installing ${dev ? "dev " : ""}dependencies: ${dependencies.map((x)=>pc.cyan(x)).join(", ")}`);
    let [name, ...args] = getInstallCommand({
        dependencies,
        packageManager,
        dev
    });
    await spawn(name, args, {
        stdio: "inherit",
        cwd,
        env: {
            ...env,
            ADBLOCK: "1",
            DISABLE_OPENCOLLECTIVE: "1"
        }
    });
}

async function checkPath(path, force) {
    try {
        logger.log(LogLevel.Debug, `Checking stats of "${path}"`);
        let stats = await stat(path);
        if (!stats.isDirectory()) throw new CLIError("Destination already exists and is not a directory", {
            output: "Destination already exists and is not a directory. Please delete it or try another path."
        });
        if (force) return !0;
        if (await isFolderEmpty(path)) {
            logger.log(LogLevel.Trace, "Path can be initialized because it is empty");
            return;
        }
        throw new CLIError("Destination already exists", {
            output: 'Destination already exists. Please empty the directory or rerun with "--force" to proceed.'
        });
    } catch (err) {
        if ("ENOENT" !== getErrorCode(err)) throw err;
        logger.log(LogLevel.Trace, "Path can be initialized because it does not exist yet");
    }
}
async function writeFiles(path, files) {
    for (let file of files){
        let filePath = join(path, file.path);
        logger.log(LogLevel.Debug, `Writing file: "${file.path}"`), await mkdir(dirname(filePath), {
            recursive: !0
        }), await writeFile(filePath, file.content);
    }
}
const initCmd = {
    command: "init [path]",
    describe: "Set up a new Kosko directory",
    builder: (argv)=>argv.option("force", {
            type: "boolean",
            describe: "Overwrite existing files",
            alias: "f"
        }).positional("path", {
            type: "string",
            describe: "Path to initialize"
        }).example("$0 init", "Initialize in current directory").example("$0 init example", "Initialize in specified directory").option("typescript", {
            type: "boolean",
            describe: "Generate TypeScript files",
            alias: "ts"
        }).option("esm", {
            type: "boolean",
            describe: "Generate ECMAScript module (ESM) files"
        }).option("install", {
            type: "boolean",
            describe: "Install dependencies automatically",
            default: !0
        }).option("package-manager", {
            type: "string",
            describe: "Package manager (npm, yarn, pnpm)",
            alias: "pm"
        }).example("$0 init --typescript", "Setup a TypeScript project"),
    async handler (args) {
        let path = args.path ? resolve(args.cwd, args.path) : args.cwd;
        await checkPath(path, args.force), logger.log(LogLevel.Info, `Creating a Kosko project in "${path}"`);
        let template = args.typescript ? args.esm ? tsEsmTemplate$1 : tsTemplate$1 : args.esm ? esmTemplate$1 : cjsTemplate$1, packageManager = args.packageManager ?? await detectPackageManager(path), runCmd = `${packageManager} run`, { dependencies , devDependencies , files  } = await template({
            path
        });
        await writeFiles(path, files);
        let cdPath = function(cwd, path) {
            if (cwd !== path) return path.startsWith(cwd + sep) ? relative(cwd, path) : path;
        }(args.cwd, path), installSuccessful = !1;
        if (args.install) try {
            dependencies?.length && await installDependencies({
                cwd: path,
                packageManager,
                dependencies
            }), devDependencies?.length && await installDependencies({
                cwd: path,
                packageManager,
                dependencies: devDependencies,
                dev: !0
            }), installSuccessful = !0;
        } catch (err) {
            logger.log(LogLevel.Warn, "Install failed", {
                error: err
            });
        }
        logger.log(LogLevel.Info, `Project created at "${path}"

Inside that directory, you can run several commands:
${[
            [
                `${runCmd} generate`,
                "Validate components and generate Kubernetes manifests."
            ],
            [
                `${runCmd} validate`,
                "Only validate components."
            ]
        ].map(([cmd, desc])=>`\n  ${pc.cyan(cmd)}\n    ${desc}`).join("\n")}

We suggest that you begin by typing:

${[
            ...cdPath ? [
                `cd ${cdPath}`
            ] : [],
            ...args.install && installSuccessful ? [] : [
                dependencies?.length ? getInstallCommand({
                    packageManager,
                    dependencies
                }).join(" ") : "",
                devDependencies?.length ? getInstallCommand({
                    packageManager,
                    dependencies: devDependencies,
                    dev: !0
                }).join(" ") : ""
            ],
            `${runCmd} generate`
        ].filter(Boolean).map((line)=>`  ${pc.cyan(line)}`).join("\n")}`);
    }
};

const validateCmd = {
    command: "validate [components..]",
    describe: "Validate components",
    builder: (argv)=>generateBuilder(argv).example("$0 validate", "Validate components").example("$0 validate foo bar", "Specify components").example("$0 validate foo_*", "Use glob syntax"),
    async handler (args) {
        let config = await loadConfig(args);
        await handler({
            args: {
                ...args,
                validate: !0
            },
            config
        }), logger.log(LogLevel.Info, "Components are valid");
    }
};

function print(data) {
    return new Promise((resolve, reject)=>{
        stdout.write(data, (err)=>{
            if (err) return reject(err);
            resolve();
        });
    });
}

function concatFiles(arr) {
    if (!arr.length) return "";
    let output = "";
    for (let s of arr)s.startsWith("---") || (output += "---\n"), output += s + "\n";
    return output;
}
function readFileString(path) {
    return logger.log(LogLevel.Debug, `Reading file "${path}"`), readFile(path, "utf8");
}
async function readFilesInDir(dir) {
    logger.log(LogLevel.Debug, `Reading directory "${dir}"`);
    let files = await readdir(dir), contents = await Promise.all(files.map((file)=>readFileString(join(dir, file))));
    return concatFiles(contents);
}
const migrateCmd = {
    command: "migrate",
    describe: "Migrate YAML into components",
    builder: (argv)=>argv.option("filename", {
            type: "string",
            describe: "File, directory to migrate",
            required: !0,
            alias: "f"
        }).example("$0 migrate -f path/to/file", "Read from the path").example("$0 migrate -f -", "Read from stdin").option("esm", {
            type: "boolean",
            describe: "Generate ECMAScript module (ESM) files"
        }),
    async handler (args) {
        var cwd;
        let file = concatFiles(await (cwd = args.cwd, Promise.all(toArray(args.filename).map(async (file)=>{
            if ("-" === file) return logger.log(LogLevel.Debug, "Reading from stdin"), getStdin();
            let path = resolve(cwd, file), stats = await stat(path);
            return stats.isDirectory() ? readFilesInDir(path) : readFileString(path);
        })))), content = await migrateString(file, {
            ...args.esm && {
                format: MigrateFormat.ESM
            }
        });
        await print(content);
    }
};

const version = "3.1.3";

function createRootCommand(args) {
    return yargs(args).scriptName("kosko").version(version).exitProcess(!1).option("cwd", {
        type: "string",
        describe: "Path of working directory",
        global: !0,
        default: cwd(),
        defaultDescription: "CWD",
        coerce: (arg)=>isAbsolute(arg) ? arg : resolve(arg)
    }).option("log-level", {
        type: "string",
        describe: "Set log level",
        global: !0,
        default: "info"
    }).option("silent", {
        type: "boolean",
        describe: "Disable log output",
        global: !0,
        default: !1
    }).group([
        "cwd",
        "log-level",
        "silent",
        "help",
        "version"
    ], "Global Options:").middleware(setupLogger).command(initCmd).command(generateCmd).command(validateCmd).command(migrateCmd).demandCommand();
}

async function run(args = argv.slice(2)) {
    await parse(createRootCommand(args), args);
}

export { run };
//# sourceMappingURL=index.node.mjs.map
