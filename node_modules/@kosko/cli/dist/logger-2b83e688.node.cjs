'use strict';

var execUtils = require('@kosko/exec-utils');
var generate = require('@kosko/generate');
var node_path = require('node:path');
var stringify = require('fast-safe-stringify');
var logger = require('@kosko/log');
var node_process = require('node:process');
var jp = require('jsonpath');
var resolveFrom = require('resolve-from');
var pkgUp = require('pkg-up');
var promises = require('node:fs/promises');
var node_url = require('node:url');
var AggregateError = require('@kosko/aggregate-error');
var cleanStack = require('clean-stack');
var extractStack = require('extract-stack');
var pc = require('picocolors');
var commonUtils = require('@kosko/common-utils');
var node_module = require('node:module');

function _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }

var stringify__default = /*#__PURE__*/_interopDefault(stringify);
var logger__default = /*#__PURE__*/_interopDefault(logger);
var jp__default = /*#__PURE__*/_interopDefault(jp);
var resolveFrom__default = /*#__PURE__*/_interopDefault(resolveFrom);
var pkgUp__default = /*#__PURE__*/_interopDefault(pkgUp);
var AggregateError__default = /*#__PURE__*/_interopDefault(AggregateError);
var cleanStack__default = /*#__PURE__*/_interopDefault(cleanStack);
var extractStack__default = /*#__PURE__*/_interopDefault(extractStack);
var pc__default = /*#__PURE__*/_interopDefault(pc);

class CLIError extends Error {
    constructor(msg, { output , code  } = {}){
        super(msg), this.output = output, this.code = code;
    }
}
CLIError.prototype.name = "CLIError";
function handleError(err) {
    let code = 1;
    err instanceof CLIError ? (null != err.code && (code = err.code), "string" == typeof err.output ? err.output && logger__default.default.log(logger.LogLevel.Error, err.output) : logger__default.default.log(logger.LogLevel.Error, err.message, {
        error: err
    })) : err instanceof Error ? "YError" !== err.name && logger__default.default.log(logger.LogLevel.Error, "", {
        error: err
    }) : logger__default.default.log(logger.LogLevel.Error, "", {
        error: err
    }), node_process.exit(code);
}

let parseRegexp = /^(.*?[^=<>~])=([^=<>~].*?$)/;
function parseKeyValuePair(s) {
    if ("string" != typeof s) throw Error(`The specified value "${s}" is not a string.`);
    let matches = s.match(parseRegexp);
    if (null == matches || 3 !== matches.length) throw Error(`Cannot parse string "${s}". Expected format is "<key>=<value>".`);
    return {
        key: matches[1],
        value: function(value) {
            try {
                return JSON.parse(value);
            } catch (e) {
                return value;
            }
        }(matches[2])
    };
}
function parseSetOptions(arg) {
    let result = [], argsArray = Array.isArray(arg) ? arg : [
        arg
    ];
    for (let argItem of argsArray)if ("object" == typeof argItem && null !== argItem) for (let argKey of Object.keys(argItem)){
        let argValues = argItem[argKey];
        for (let value of (Array.isArray(argValues) || (argValues = [
            argValues
        ]), argValues))result.push({
            ...parseKeyValuePair(value),
            componentName: argKey
        });
    }
    else result.push(parseKeyValuePair(argItem));
    return result;
}
function createCLIEnvReducer(setOptions) {
    for (let opt of setOptions)try {
        jp__default.default.parse(opt.key);
    } catch (err) {
        throw new CLIError(err.message, {
            code: 1,
            output: `Invalid JSONPath expression "${opt.key}": ${err.message}`
        });
    }
    let argsOrdered = setOptions.sort((a, b)=>a.componentName === b.componentName ? 0 : a.componentName ? 1 : -1);
    return {
        name: "cli",
        reduce (target, componentName) {
            for (let variable of argsOrdered){
                let isGlobalVariable = !variable.componentName;
                (isGlobalVariable || variable.componentName === componentName) && jp__default.default.apply(target, "$." + variable.key, ()=>variable.value);
            }
            return target;
        }
    };
}

async function importDefault(id) {
    let mod = await import(id);
    return mod.default;
}
async function getESMEntry(cwd) {
    let pkgPath = await pkgUp__default.default({
        cwd
    });
    if (!pkgPath) return;
    let pkg = JSON.parse(await promises.readFile(pkgPath, "utf-8"));
    if (!pkg.module) return;
    let path = node_path.join(pkgPath, "..", pkg.module);
    return node_url.pathToFileURL(path).toString();
}
async function importEnvNode(cwd) {
    let envPath = resolveFrom__default.default(cwd, "@kosko/env"), envs = [];
    if (envs.push(require(envPath)), "1" !== node_process.env.ESM_IMPORT_DISABLED) {
        let envModUrl = await getESMEntry(node_path.dirname(envPath));
        envModUrl && envs.push(await importDefault(envModUrl));
    }
    return envs;
}
async function setupEnv(config, args) {
    let cwd = args.cwd, envs = await importEnvNode(cwd), paths = config.paths?.environment || {}, setReducer = args.set?.length ? createCLIEnvReducer(args.set) : void 0;
    for (let env of envs){
        var envs1;
        env.cwd = cwd, env.env = (envs1 = [
            config.baseEnvironment,
            args.env
        ].filter(Boolean)).length > 1 ? envs1 : envs1[0], config.extensions && (env.extensions = [
            ...config.extensions
        ]), paths.global && (env.paths.global = paths.global), paths.component && (env.paths.component = paths.component), setReducer && env.setReducers((reducers)=>[
                ...reducers,
                setReducer
            ]);
    }
}

var _pathErrorsMap;
function print(line) {
    node_process.stderr.write(line + "\n");
}
function getErrorCount(n) {
    return `${n} error${1 === n ? "" : "s"}`;
}
function toErrorLike(err) {
    if (err instanceof Error) return err;
    if (commonUtils.isRecord(err)) {
        let { name , message , stack  } = err;
        if ("string" == typeof message) return {
            name: "string" == typeof name && name || "Error",
            message,
            ..."string" == typeof stack && {
                stack
            }
        };
    }
    if ("string" == typeof err) return {
        name: "Error",
        message: err
    };
}
function getFormattedErrorTitle(err) {
    return "  " + pc__default.default.red(`âœ– ${err.name}: ${err.message}`);
}
function getFormattedErrorStack(err, extraIndent = "") {
    if ("string" != typeof err.stack) return;
    let stack = cleanStack__default.default(extractStack__default.default(err));
    return extraIndent && (stack = stack.split("\n").map((line)=>extraIndent + line).join("\n")), pc__default.default.gray(stack);
}
function stringifyResolveError(err) {
    let lines = [
        getFormattedErrorTitle(err)
    ];
    function appendMeta(name, value) {
        lines.push(`    ${name}: ${value}`);
    }
    if (err.index?.length && appendMeta("Index", `[${err.index.join(", ")}]`), err.component) {
        let { apiVersion , kind , name , namespace  } = err.component;
        appendMeta("Kind", `${apiVersion}/${kind}`), namespace && appendMeta("Namespace", namespace), appendMeta("Name", name);
    }
    let cause = function(cause) {
        if (commonUtils.isRecord(cause) && !0 === cause.ajv && !0 === cause.validation && Array.isArray(cause.errors)) return "\n" + cause.errors.map((err)=>{
            let msg;
            return `      ${msg = err.instancePath, err.message && (msg += ` ${err.message}`), "enum" === err.keyword && commonUtils.isRecord(err.params) && Array.isArray(err.params.allowedValues) && (msg += `: ${stringify__default.default(err.params.allowedValues)}`), msg}`;
        }).join("\n");
        let err = toErrorLike(cause);
        if (err) return [
            `    ${err.name}: ${err.message}`,
            getFormattedErrorStack(err, "  ")
        ].join("\n");
    }(err.cause);
    return cause && lines.push(cause), lines.join("\n");
}
function handleGenerateError(cwd, error, options) {
    let allErrors = function flattenError(err) {
        return err instanceof AggregateError__default.default ? err.errors.flatMap(flattenError) : [
            err
        ];
    }(error), pathErrorsMap = {}, unknownErrors = [];
    function pushToPathErrorsMap(path, value) {
        (_pathErrorsMap = pathErrorsMap)[path] ?? (_pathErrorsMap[path] = []), pathErrorsMap[path].push(value);
    }
    for (let err of allErrors)if (err instanceof generate.ResolveError && err.path) pushToPathErrorsMap(err.path, stringifyResolveError(err));
    else if (err instanceof generate.GenerateError && err.path) pushToPathErrorsMap(err.path, stringifyResolveError(err));
    else {
        let e = toErrorLike(err);
        e && unknownErrors.push(e);
    }
    for (let [path, errors] of Object.entries(pathErrorsMap)){
        var path1;
        for (let err1 of (print(`${pc__default.default.bold(((path1 = path).startsWith(cwd) && (path1 = path1.substring(cwd.length).replace(/^[/\\]+/, "")), path1.replace(/\\/g, "/")))} - ${getErrorCount(errors.length)}\n`), errors))print(err1 + "\n");
    }
    if (unknownErrors.length) for (let err2 of (print(pc__default.default.bold(`Other ${getErrorCount(unknownErrors.length)}\n`)), unknownErrors)){
        let stack = getFormattedErrorStack(err2);
        print(`${getFormattedErrorTitle(err2)}\n`), stack && print(`${stack}\n`);
    }
    return new CLIError("Generate failed", {
        output: `Generate failed (${options.bail ? "Only the first error is displayed because `bail` option is enabled" : `Total ${getErrorCount(allErrors.length)}`})`
    });
}

async function doGenerate({ cwd , ...options }) {
    try {
        return await generate.generate({
            ...options,
            path: node_path.join(cwd, "components")
        });
    } catch (err) {
        throw handleGenerateError(cwd, err, options);
    }
}
async function handler(options) {
    let { printFormat , args , config , ignoreLoaders  } = options;
    if (!ignoreLoaders && config.loaders.length) {
        await runWithLoaders(options);
        return;
    }
    if (await setupEnv(config, args), config.require.length) {
        let req = node_module.createRequire(node_path.join(args.cwd, "noop.js"));
        for (let id of config.require)req(id);
    }
    let result = await doGenerate({
        cwd: args.cwd,
        components: config.components,
        extensions: config.extensions,
        validate: args.validate,
        bail: config.bail,
        concurrency: config.concurrency
    });
    if (!result.manifests.length) throw new CLIError("No manifests are exported from components", {
        output: "No manifests are exported from components. Make sure there are exported manifests in components."
    });
    printFormat && generate.print(result, {
        format: printFormat,
        writer: node_process.stdout
    });
}
async function runWithLoaders(options) {
    try {
        await execUtils.spawn(node_process.execPath, [
            ...node_process.execArgv,
            ...options.config.loaders.flatMap((loader)=>[
                    "--loader",
                    loader
                ]),
            node_path.join(node_url.fileURLToPath(new URL(`file:${__filename}`).href), "../worker-bin.node.cjs")
        ], {
            stdio: [
                "pipe",
                "inherit",
                "inherit"
            ],
            input: stringify__default.default(options)
        });
    } catch (err) {
        if (err instanceof execUtils.SpawnError) throw new CLIError(err.message, {
            output: "",
            code: err.exitCode
        });
        throw err;
    }
}

function setupLogger(args) {
    if (args.silent) logger__default.default.setWriter(new logger.SilentLogWriter());
    else {
        let level = args["log-level"];
        logger__default.default.setLevel(level && logger.logLevelFromString(level) || logger.LogLevel.Info);
    }
}

exports.CLIError = CLIError;
exports.handleError = handleError;
exports.handler = handler;
exports.parseSetOptions = parseSetOptions;
exports.setupLogger = setupLogger;
//# sourceMappingURL=logger-2b83e688.node.cjs.map
