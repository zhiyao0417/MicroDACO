import { loadAll } from 'js-yaml';
import { readFile } from 'node:fs/promises';
import logger, { LogLevel } from '@kosko/log';
import stringify from 'fast-safe-stringify';
import { isRecord } from '@kosko/common-utils';

async function importModule(id) {
    return import(id);
}

let moduleMap = {};
function setResourceModule(res, mod) {
    let { apiVersion , kind  } = res;
    moduleMap[apiVersion] || (moduleMap[apiVersion] = {}), moduleMap[apiVersion][kind] = mod, logger.log(LogLevel.Debug, "Set resource module", {
        data: {
            resourceKind: res,
            resourceModule: mod
        }
    });
}
async function getKubernetesModels(res) {
    let { apiVersion , kind  } = res, group = function(apiVersion) {
        let arr = apiVersion.split("/");
        return 1 === arr.length ? "" : arr[0];
    }(apiVersion);
    if (group && group.includes(".") && !group.endsWith(".k8s.io")) return;
    let path = `kubernetes-models/${apiVersion}/${kind}`;
    try {
        let result = await importModule(path);
        if (result?.[kind]) {
            let mod = {
                path,
                export: kind
            };
            return setResourceModule(res, mod), mod;
        }
    } catch  {
        return;
    }
}
async function getResourceModule(res) {
    return moduleMap[res.apiVersion]?.[res.kind] ?? await getKubernetesModels(res);
}
function resetResourceModules() {
    moduleMap = {}, logger.log(LogLevel.Debug, "Reset resource modules");
}

var defaultFetch = (function() {
    if ("function" == typeof fetch) return fetch;
    throw Error("fetch is undefined");
})();

async function getConstructor(res) {
    let mod = await getResourceModule(res);
    if (!mod) {
        logger.log(LogLevel.Debug, "No resource modules", {
            data: res
        });
        return;
    }
    try {
        let result = await importModule(mod.path);
        return result[mod.export];
    } catch  {
        logger.log(LogLevel.Debug, "Failed to import the resource module", {
            data: mod
        });
        return;
    }
}
async function loadString(content, options = {}) {
    let { transform =(x)=>x  } = options, input = loadAll(content).filter((x)=>null != x), manifests = [];
    for (let entry of input){
        var value;
        if (!isRecord(entry)) throw Error(`The value must be an object: ${stringify(entry)}`);
        if (!("string" == typeof (value = entry).apiVersion && value.apiVersion && "string" == typeof value.kind && value.kind)) throw Error(`apiVersion and kind are required: ${stringify(entry)}`);
        let Constructor = await getConstructor(entry), manifest = transform(Constructor ? new Constructor(entry) : entry);
        manifest && manifests.push(manifest);
    }
    return manifests;
}
function loadFile(path, options) {
    return async ()=>{
        let content = await readFile(path, "utf-8");
        return logger.log(LogLevel.Debug, `File loaded from: ${path}`), loadString(content, options);
    };
}
function loadUrl(url, options = {}) {
    let { transform , fetch =defaultFetch , ...init } = options;
    return async ()=>{
        let res = await fetch(url, init);
        if (logger.log(LogLevel.Debug, "Fetched YAML", {
            data: {
                url,
                status: res.status
            }
        }), !res.ok) throw Error(`Failed to fetch YAML file from: ${url}`);
        return loadString(await res.text(), {
            transform
        });
    };
}

export { getResourceModule, loadFile, loadString, loadUrl, resetResourceModules, setResourceModule };
//# sourceMappingURL=index.base.mjs.map
